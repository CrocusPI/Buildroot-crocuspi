From 7dc099f2ee318b44a87aaf6d2e87ca9547ddf024 Mon Sep 17 00:00:00 2001
From: YuzukiTsuru <gloomyghost@gloomyghost.com>
Date: Sun, 6 Mar 2022 20:40:33 +0800
Subject: [PATCH 05/22] arch: add suniv basic dram clock cpu info

---
 arch/arm/include/asm/arch-sunxi/clock.h       |   2 +
 arch/arm/include/asm/arch-sunxi/clock_suniv.h | 562 ++++++++++++++++++
 arch/arm/include/asm/arch-sunxi/cpu.h         |   2 +
 arch/arm/include/asm/arch-sunxi/cpu_suniv.h   | 232 ++++++++
 arch/arm/include/asm/arch-sunxi/dram.h        |   2 +
 arch/arm/include/asm/arch-sunxi/dram_suniv.h  |  53 ++
 arch/arm/include/asm/arch-sunxi/gpio.h        |   3 +
 arch/arm/mach-sunxi/Kconfig                   |   3 +-
 arch/arm/mach-sunxi/Makefile                  |   2 +
 arch/arm/mach-sunxi/board.c                   |  50 +-
 arch/arm/mach-sunxi/clock.c                   |   3 +-
 arch/arm/mach-sunxi/clock_suniv.c             | 392 ++++++++++++
 arch/arm/mach-sunxi/dram_helpers.c            |   4 +
 arch/arm/mach-sunxi/dram_suniv.c              | 484 +++++++++++++++
 arch/arm/mach-sunxi/spl_spi_sunxi.c           | 228 +++++--
 15 files changed, 1969 insertions(+), 53 deletions(-)
 create mode 100644 arch/arm/include/asm/arch-sunxi/clock_suniv.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/cpu_suniv.h
 create mode 100644 arch/arm/include/asm/arch-sunxi/dram_suniv.h
 create mode 100644 arch/arm/mach-sunxi/clock_suniv.c
 create mode 100644 arch/arm/mach-sunxi/dram_suniv.c

diff --git a/arch/arm/include/asm/arch-sunxi/clock.h b/arch/arm/include/asm/arch-sunxi/clock.h
index 5994130e..9d2391e0 100644
--- a/arch/arm/include/asm/arch-sunxi/clock.h
+++ b/arch/arm/include/asm/arch-sunxi/clock.h
@@ -23,6 +23,8 @@
 #include <asm/arch/clock_sun6i.h>
 #elif defined(CONFIG_MACH_SUN9I)
 #include <asm/arch/clock_sun9i.h>
+#elif defined(CONFIG_MACH_SUNIV)
+#include <asm/arch/clock_suniv.h>
 #else
 #include <asm/arch/clock_sun4i.h>
 #endif
diff --git a/arch/arm/include/asm/arch-sunxi/clock_suniv.h b/arch/arm/include/asm/arch-sunxi/clock_suniv.h
new file mode 100644
index 00000000..f3781a4c
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/clock_suniv.h
@@ -0,0 +1,562 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * SUNIV clock register definitions
+ *
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * (C) Copyright 2022
+ * YuzukiTsuru <gloomyghost@gloomyghost.com>
+ *
+ */
+
+#ifndef _SUNXI_CLOCK_SUNIV_H
+#define _SUNXI_CLOCK_SUNIV_H
+
+struct sunxi_ccm_reg {
+	u32 pll1_cfg;		/* 0x00 pll1 control */
+	u32 reserved0;
+	u32 pll2_cfg;		/* 0x08 pll2 control */
+	u32 reserved1;
+	u32 pll3_cfg;		/* 0x10 pll3 control */
+	u32 reserved2;
+	u32 pll4_cfg;		/* 0x18 pll4 control */
+	u32 reserved3;
+	u32 pll5_cfg;		/* 0x20 pll5 control */
+	u32 reserved4;
+	u32 pll6_cfg;		/* 0x28 pll6 control */
+	u32 reserved5;
+	u32 pll7_cfg;		/* 0x30 pll7 control */
+	u32 sata_pll_cfg;	/* 0x34 SATA pll control (R40 only) */
+	u32 pll8_cfg;		/* 0x38 pll8 control */
+	u32 reserved7;
+	u32 mipi_pll_cfg;	/* 0x40 MIPI pll control */
+	u32 pll9_cfg;		/* 0x44 pll9 control */
+	u32 pll10_cfg;		/* 0x48 pll10 control */
+	u32 pll11_cfg;		/* 0x4c pll11 (ddr1) control (A33 only) */
+	u32 cpu_axi_cfg;	/* 0x50 CPU/AXI divide ratio */
+	u32 ahb1_apb1_div;	/* 0x54 AHB1/APB1 divide ratio */
+	u32 apb2_div;		/* 0x58 APB2 divide ratio */
+	u32 axi_gate;		/* 0x5c axi module clock gating */
+	u32 ahb_gate0;		/* 0x60 ahb module clock gating 0 */
+	u32 ahb_gate1;		/* 0x64 ahb module clock gating 1 */
+	u32 apb1_gate;		/* 0x68 apb1 module clock gating */
+	u32 apb2_gate;		/* 0x6c apb2 module clock gating */
+	u32 bus_gate4;          /* 0x70 gate 4 module clock gating */
+	u8 res3[0xc];
+	u32 nand0_clk_cfg;	/* 0x80 nand0 clock control */
+	u32 nand1_clk_cfg;	/* 0x84 nand1 clock control */
+	u32 sd0_clk_cfg;	/* 0x88 sd0 clock control */
+	u32 sd1_clk_cfg;	/* 0x8c sd1 clock control */
+	u32 sd2_clk_cfg;	/* 0x90 sd2 clock control */
+	u32 sd3_clk_cfg;	/* 0x94 sd3 clock control */
+	u32 ts_clk_cfg;		/* 0x98 transport stream clock control */
+	u32 ss_clk_cfg;		/* 0x9c security system clock control */
+	u32 spi0_clk_cfg;	/* 0xa0 spi0 clock control */
+	u32 spi1_clk_cfg;	/* 0xa4 spi1 clock control */
+	u32 spi2_clk_cfg;	/* 0xa8 spi2 clock control */
+	u32 spi3_clk_cfg;	/* 0xac spi3 clock control */
+	u32 i2s0_clk_cfg;	/* 0xb0 I2S0 clock control*/
+	u32 i2s1_clk_cfg;	/* 0xb4 I2S1 clock control */
+	u32 reserved10[2];
+	u32 spdif_clk_cfg;	/* 0xc0 SPDIF clock control */
+	u32 reserved11;
+	u32 sata_clk_cfg;	/* 0xc8 SATA clock control (R40 only) */
+	u32 usb_clk_cfg;	/* 0xcc USB clock control */
+#ifdef CONFIG_MACH_SUN8I_R40
+	u32 cir0_clk_cfg;	/* 0xd0 CIR0 clock control (R40 only) */
+#else
+	u32 gmac_clk_cfg;	/* 0xd0 GMAC clock control (not for R40) */
+#endif
+	u32 reserved12[7];
+	u32 mdfs_clk_cfg;	/* 0xf0 MDFS clock control */
+	u32 dram_clk_cfg;	/* 0xf4 DRAM configuration clock control */
+	u32 dram_pll_cfg;	/* 0xf8 PLL_DDR cfg register, A33 only */
+	u32 mbus_reset;		/* 0xfc MBUS reset control, A33 only */
+	u32 dram_clk_gate;	/* 0x100 DRAM module gating */
+#ifdef CONFIG_SUNXI_DE2
+	u32 de_clk_cfg;		/* 0x104 DE module clock */
+#else
+	u32 be0_clk_cfg;	/* 0x104 BE0 module clock */
+#endif
+	u32 be1_clk_cfg;	/* 0x108 BE1 module clock */
+	u32 fe0_clk_cfg;	/* 0x10c FE0 module clock */
+	u32 fe1_clk_cfg;	/* 0x110 FE1 module clock */
+	u32 mp_clk_cfg;		/* 0x114 MP module clock */
+#ifdef CONFIG_SUNXI_DE2
+	u32 lcd0_clk_cfg;	/* 0x118 LCD0 module clock */
+	u32 lcd1_clk_cfg;	/* 0x11c LCD1 module clock */
+#else
+	u32 lcd0_ch0_clk_cfg;	/* 0x118 LCD0 CH0 module clock */
+	u32 lcd1_ch0_clk_cfg;	/* 0x11c LCD1 CH0 module clock */
+#endif
+	u32 tve_clk_cfg;	/* 0x120 H3/H5 TVE module clock */
+	u32 reserved14[2];
+	u32 lcd0_ch1_clk_cfg;	/* 0x12c LCD0 CH1 module clock */
+	u32 lcd1_ch1_clk_cfg;	/* 0x130 LCD1 CH1 module clock */
+	u32 csi0_clk_cfg;	/* 0x134 CSI0 module clock */
+	u32 csi1_clk_cfg;	/* 0x138 CSI1 module clock */
+	u32 ve_clk_cfg;		/* 0x13c VE module clock */
+	u32 adda_clk_cfg;	/* 0x140 ADDA module clock */
+	u32 avs_clk_cfg;	/* 0x144 AVS module clock */
+	u32 dmic_clk_cfg;	/* 0x148 Digital Mic module clock*/
+	u32 reserved15;
+	u32 hdmi_clk_cfg;	/* 0x150 HDMI module clock */
+#ifdef CONFIG_SUNXI_DE2
+	u32 hdmi_slow_clk_cfg;	/* 0x154 HDMI slow module clock */
+#else
+	u32 ps_clk_cfg;		/* 0x154 PS module clock */
+#endif
+	u32 mtc_clk_cfg;	/* 0x158 MTC module clock */
+	u32 mbus0_clk_cfg;	/* 0x15c MBUS0 module clock */
+	u32 mbus1_clk_cfg;	/* 0x160 MBUS1 module clock */
+#ifdef CONFIG_MACH_SUN8I_R40
+	u32 gmac_clk_cfg;	/* 0x164 GMAC clock control (R40 only) */
+#else
+	u32 reserved16;
+#endif
+	u32 mipi_dsi_clk_cfg;	/* 0x168 MIPI DSI clock control */
+	u32 mipi_csi_clk_cfg;	/* 0x16c MIPI CSI clock control */
+	u32 reserved17[4];
+	u32 iep_drc0_clk_cfg;	/* 0x180 IEP DRC0 module clock */
+	u32 iep_drc1_clk_cfg;	/* 0x184 IEP DRC1 module clock */
+	u32 iep_deu0_clk_cfg;	/* 0x188 IEP DEU0 module clock */
+	u32 iep_deu1_clk_cfg;	/* 0x18c IEP DEU1 module clock */
+	u32 reserved18[4];
+	u32 gpu_core_clk_cfg;	/* 0x1a0 GPU core clock config */
+	u32 gpu_mem_clk_cfg;	/* 0x1a4 GPU memory clock config */
+	u32 gpu_hyd_clk_cfg;	/* 0x1a0 GPU HYD clock config */
+	u32 reserved19[21];
+	u32 pll_lock;		/* 0x200 PLL Lock Time */
+	u32 pll1_lock;		/* 0x204 PLL1 Lock Time */
+	u32 reserved20[6];
+	u32 pll1_bias_cfg;	/* 0x220 PLL1 Bias config */
+	u32 pll2_bias_cfg;	/* 0x224 PLL2 Bias config */
+	u32 pll3_bias_cfg;	/* 0x228 PLL3 Bias config */
+	u32 pll4_bias_cfg;	/* 0x22c PLL4 Bias config */
+	u32 pll5_bias_cfg;	/* 0x230 PLL5 Bias config */
+	u32 pll6_bias_cfg;	/* 0x234 PLL6 Bias config */
+	u32 pll7_bias_cfg;	/* 0x238 PLL7 Bias config */
+	u32 pll8_bias_cfg;	/* 0x23c PLL8 Bias config */
+	u32 mipi_bias_cfg;	/* 0x240 MIPI Bias config */
+	u32 pll9_bias_cfg;	/* 0x244 PLL9 Bias config */
+	u32 pll10_bias_cfg;	/* 0x248 PLL10 Bias config */
+	u32 reserved21[5];
+	u32 pll5_tuning_cfg;	/* 0x260 PLL5 Tuning config */
+	u32 reserved21_5[7];
+	u32 pll1_pattern_cfg;	/* 0x280 PLL1 Pattern config */
+	u32 pll2_pattern_cfg;	/* 0x284 PLL2 Pattern config */
+	u32 pll3_pattern_cfg;	/* 0x288 PLL3 Pattern config */
+	u32 pll4_pattern_cfg;	/* 0x28c PLL4 Pattern config */
+	u32 pll5_pattern_cfg;	/* 0x290 PLL5 Pattern config */
+	u32 pll6_pattern_cfg;	/* 0x294 PLL6 Pattern config */
+	u32 pll7_pattern_cfg;	/* 0x298 PLL7 Pattern config */
+	u32 pll8_pattern_cfg;	/* 0x29c PLL8 Pattern config */
+	u32 mipi_pattern_cfg;	/* 0x2a0 MIPI Pattern config */
+	u32 pll9_pattern_cfg;	/* 0x2a4 PLL9 Pattern config */
+	u32 pll10_pattern_cfg;	/* 0x2a8 PLL10 Pattern config */
+	u32 pll11_pattern_cfg0; /* 0x2ac PLL11 Pattern config0, A33 only */
+	u32 pll11_pattern_cfg1; /* 0x2b0 PLL11 Pattern config0, A33 only */
+	u32 reserved22[3];
+	u32 ahb_reset0_cfg;	/* 0x2c0 AHB1 Reset 0 config */
+	u32 ahb_reset1_cfg;	/* 0x2c4 AHB1 Reset 1 config */
+	u32 ahb_reset2_cfg;	/* 0x2c8 AHB1 Reset 2 config */
+	u32 reserved23;
+	u32 apb1_reset_cfg;	/* 0x2d0 APB1 Reset config */
+	u32 reserved24;
+	u32 apb2_reset_cfg;	/* 0x2d8 APB2 Reset config */
+	u32 reserved25[5];
+	u32 ccu_sec_switch;	/* 0x2f0 CCU Security Switch, H3 only */
+	u32 reserved26[11];
+	u32 pll_lock_ctrl;	/* 0x320 PLL lock control, R40 only */
+};
+
+/* apb1 bit field */
+#ifdef CONFIG_MACH_SUNIV
+#define APB1_GATE_UART_SHIFT	(20)
+#define APB1_GATE_UART_MASK		(0x7 << APB1_GATE_UART_SHIFT)
+#define APB1_GATE_TWI_SHIFT	    (16)
+#define APB1_GATE_TWI_MASK		(0x7 << APB1_GATE_TWI_SHIFT)
+#endif
+
+/* apb2 bit field */
+#define APB2_CLK_SRC_LOSC		(0x0 << 24)
+#define APB2_CLK_SRC_OSC24M		(0x1 << 24)
+#define APB2_CLK_SRC_PLL6		(0x2 << 24)
+#define APB2_CLK_SRC_MASK		(0x3 << 24)
+#define APB2_CLK_RATE_N_1		(0x0 << 16)
+#define APB2_CLK_RATE_N_2		(0x1 << 16)
+#define APB2_CLK_RATE_N_4		(0x2 << 16)
+#define APB2_CLK_RATE_N_8		(0x3 << 16)
+#define APB2_CLK_RATE_N_MASK    (3 << 16)
+#define APB2_CLK_RATE_M			(m)		(((m)-1) << 0)
+#define APB2_CLK_RATE_M_MASK            (0x1f << 0)
+
+/* apb2 gate field */
+#define APB2_GATE_UART_SHIFT	(16)
+#define APB2_GATE_UART_MASK		(0xff << APB2_GATE_UART_SHIFT)
+#define APB2_GATE_TWI_SHIFT		(0)
+#define APB2_GATE_TWI_MASK		(0xf << APB2_GATE_TWI_SHIFT)
+
+/* cpu_axi_cfg bits */
+#define AXI_DIV_SHIFT			0
+#define ATB_DIV_SHIFT			8
+#define CPU_CLK_SRC_SHIFT		16
+
+#define AXI_DIV_1			0
+#define AXI_DIV_2			1
+#define AXI_DIV_3			2
+#define AXI_DIV_4			3
+#define ATB_DIV_1			0
+#define ATB_DIV_2			1
+#define ATB_DIV_4			2
+#define AHB_DIV_1			0
+#define CPU_CLK_SRC_OSC24M		1
+#define CPU_CLK_SRC_PLL1		2
+
+#define CCM_PLL1_CTRL_M(n)		((((n) - 1) & 0x3) << 0)
+#define CCM_PLL1_CTRL_K(n)		((((n) - 1) & 0x3) << 4)
+#define CCM_PLL1_CTRL_N(n)		((((n) - 1) & 0x1f) << 8)
+#define CCM_PLL1_CTRL_P(n)		(((n) & 0x3) << 16)
+#define CCM_PLL1_CTRL_EN		(0x1 << 31)
+
+#define CCM_PLL3_CTRL_M_SHIFT		0
+#define CCM_PLL3_CTRL_M_MASK		(0xf << CCM_PLL3_CTRL_M_SHIFT)
+#define CCM_PLL3_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_PLL3_CTRL_N_SHIFT		8
+#define CCM_PLL3_CTRL_N_MASK		(0x7f << CCM_PLL3_CTRL_N_SHIFT)
+#define CCM_PLL3_CTRL_N(n)		((((n) - 1) & 0x7f) << 8)
+#define CCM_PLL3_CTRL_INTEGER_MODE	(0x1 << 24)
+#define CCM_PLL3_CTRL_LOCK		(0x1 << 28)
+#define CCM_PLL3_CTRL_EN		(0x1 << 31)
+
+#define CCM_PLL5_CTRL_M(n)		((((n) - 1) & 0x3) << 0)
+#define CCM_PLL5_CTRL_K(n)		((((n) - 1) & 0x3) << 4)
+#define CCM_PLL5_CTRL_N(n)		((((n) - 1) & 0x1f) << 8)
+#define CCM_PLL5_CTRL_UPD		(0x1 << 20)
+#define CCM_PLL5_CTRL_SIGMA_DELTA_EN	(0x1 << 24)
+#define CCM_PLL5_CTRL_EN		(0x1 << 31)
+
+#if !defined(CONFIG_MACH_SUNIV)
+#define PLL6_CFG_DEFAULT		0x90041811 /* 600 MHz */
+#else
+/* suniv pll6 doesn't have postdiv 2, so k is set to 0 */
+#define PLL6_CFG_DEFAULT		0x90041800
+#endif
+
+#define CCM_PLL6_CTRL_N_SHIFT		8
+#define CCM_PLL6_CTRL_N_MASK		(0x1f << CCM_PLL6_CTRL_N_SHIFT)
+#define CCM_PLL6_CTRL_K_SHIFT		4
+#define CCM_PLL6_CTRL_K_MASK		(0x3 << CCM_PLL6_CTRL_K_SHIFT)
+#define CCM_PLL6_CTRL_LOCK		(1 << 28)
+
+#define CCM_SATA_PLL_DEFAULT		0x90005811 /* 100 MHz */
+
+#define CCM_MIPI_PLL_CTRL_M_SHIFT	0
+#define CCM_MIPI_PLL_CTRL_M_MASK	(0xf << CCM_MIPI_PLL_CTRL_M_SHIFT)
+#define CCM_MIPI_PLL_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_MIPI_PLL_CTRL_K_SHIFT	4
+#define CCM_MIPI_PLL_CTRL_K_MASK	(0x3 << CCM_MIPI_PLL_CTRL_K_SHIFT)
+#define CCM_MIPI_PLL_CTRL_K(n)		((((n) - 1) & 0x3) << 4)
+#define CCM_MIPI_PLL_CTRL_N_SHIFT	8
+#define CCM_MIPI_PLL_CTRL_N_MASK	(0xf << CCM_MIPI_PLL_CTRL_N_SHIFT)
+#define CCM_MIPI_PLL_CTRL_N(n)		((((n) - 1) & 0xf) << 8)
+#define CCM_MIPI_PLL_CTRL_LDO_EN	(0x3 << 22)
+#define CCM_MIPI_PLL_CTRL_EN		(0x1 << 31)
+
+#define CCM_PLL10_CTRL_M_SHIFT		0
+#define CCM_PLL10_CTRL_M_MASK		(0xf << CCM_PLL10_CTRL_M_SHIFT)
+#define CCM_PLL10_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_PLL10_CTRL_N_SHIFT		8
+#define CCM_PLL10_CTRL_N_MASK		(0x7f << CCM_PLL10_CTRL_N_SHIFT)
+#define CCM_PLL10_CTRL_N(n)		((((n) - 1) & 0x7f) << 8)
+#define CCM_PLL10_CTRL_INTEGER_MODE	(0x1 << 24)
+#define CCM_PLL10_CTRL_LOCK		(0x1 << 28)
+#define CCM_PLL10_CTRL_EN		(0x1 << 31)
+
+#define CCM_PLL11_CTRL_N(n)		((((n) - 1) & 0x3f) << 8)
+#define CCM_PLL11_CTRL_SIGMA_DELTA_EN	(0x1 << 24)
+#define CCM_PLL11_CTRL_UPD		(0x1 << 30)
+#define CCM_PLL11_CTRL_EN		(0x1 << 31)
+
+#define CCM_PLL5_TUN_LOCK_TIME(x)	(((x) & 0x7) << 24)
+#define CCM_PLL5_TUN_LOCK_TIME_MASK	CCM_PLL5_TUN_LOCK_TIME(0x7)
+#define CCM_PLL5_TUN_INIT_FREQ(x)	(((x) & 0x7f) << 16)
+#define CCM_PLL5_TUN_INIT_FREQ_MASK	CCM_PLL5_TUN_INIT_FREQ(0x7f)
+
+#if defined(CONFIG_MACH_SUN50I)
+/* AHB1=100MHz failsafe setup from the FEL mode, usable with PMIC defaults */
+#define AHB1_ABP1_DIV_DEFAULT		0x00003190 /* AHB1=PLL6/6,APB1=AHB1/2 */
+#else
+#define AHB1_ABP1_DIV_DEFAULT		0x00003180 /* AHB1=PLL6/3,APB1=AHB1/2 */
+#endif
+
+#define AXI_GATE_OFFSET_DRAM		0
+
+/* ahb_gate0 offsets */
+#ifdef CONFIG_MACH_SUNXI_H3_H5
+/*
+ * These are EHCI1 - EHCI3 in the datasheet (EHCI0 is for the OTG) we call
+ * them 0 - 2 like they were called on older SoCs.
+ */
+#define AHB_GATE_OFFSET_USB_OHCI3	31
+#define AHB_GATE_OFFSET_USB_OHCI2	30
+#define AHB_GATE_OFFSET_USB_OHCI1	29
+#define AHB_GATE_OFFSET_USB_OHCI0	28
+#define AHB_GATE_OFFSET_USB_EHCI3	27
+#define AHB_GATE_OFFSET_USB_EHCI2	26
+#define AHB_GATE_OFFSET_USB_EHCI1	25
+#define AHB_GATE_OFFSET_USB_EHCI0	24
+#elif defined(CONFIG_MACH_SUN50I)
+#define AHB_GATE_OFFSET_USB_OHCI0	28
+#define AHB_GATE_OFFSET_USB_OHCI1	29
+#define AHB_GATE_OFFSET_USB_EHCI0	24
+#define AHB_GATE_OFFSET_USB_EHCI1	25
+#else
+#define AHB_GATE_OFFSET_USB_OHCI1	30
+#define AHB_GATE_OFFSET_USB_OHCI0	29
+#define AHB_GATE_OFFSET_USB_EHCI1	27
+#define AHB_GATE_OFFSET_USB_EHCI0	26
+#endif
+#if defined(CONFIG_MACH_SUN50I) || defined(CONFIG_MACH_SUNXI_H3_H5)
+#define AHB_GATE_OFFSET_USB0		23
+#elif !defined(CONFIG_MACH_SUN8I_R40)
+#define AHB_GATE_OFFSET_USB0		24
+#else
+#define AHB_GATE_OFFSET_USB0		25
+#define AHB_GATE_OFFSET_SATA		24
+#endif
+#define AHB_GATE_OFFSET_SPI1		21
+#define AHB_GATE_OFFSET_SPI0		20
+#define AHB_GATE_OFFSET_MCTL		14
+#define AHB_GATE_OFFSET_GMAC		17
+#define AHB_GATE_OFFSET_NAND0		13
+#define AHB_GATE_OFFSET_NAND1		12
+#define AHB_GATE_OFFSET_MMC3		11
+#define AHB_GATE_OFFSET_MMC2		10
+#define AHB_GATE_OFFSET_MMC1		9
+#define AHB_GATE_OFFSET_MMC0		8
+#define AHB_GATE_OFFSET_MMC(n)		(AHB_GATE_OFFSET_MMC0 + (n))
+#define AHB_GATE_OFFSET_DMA		6
+#define AHB_GATE_OFFSET_SS		5
+
+/* ahb_gate1 offsets */
+#define AHB_GATE_OFFSET_DRC0		25
+#define AHB_GATE_OFFSET_DE_FE0		14
+#define AHB_GATE_OFFSET_DE_BE0		12
+#define AHB_GATE_OFFSET_DE		12
+#define AHB_GATE_OFFSET_HDMI		11
+#define AHB_GATE_OFFSET_TVE		9
+#ifndef CONFIG_SUNXI_DE2
+#define AHB_GATE_OFFSET_LCD1		5
+#define AHB_GATE_OFFSET_LCD0		4
+#else
+#define AHB_GATE_OFFSET_LCD1		4
+#define AHB_GATE_OFFSET_LCD0		3
+#endif
+
+#define CCM_NAND_CTRL_M(x)		((x) - 1)
+#define CCM_NAND_CTRL_N(x)		((x) << 16)
+#define CCM_NAND_CTRL_PLL6		(0x1 << 24)
+#define CCM_NAND_CTRL_ENABLE		(0x1 << 31)
+
+#define CCM_MMC_CTRL_M(x)		((x) - 1)
+#define CCM_MMC_CTRL_OCLK_DLY(x)	((x) << 8)
+#define CCM_MMC_CTRL_N(x)		((x) << 16)
+#define CCM_MMC_CTRL_SCLK_DLY(x)	((x) << 20)
+#define CCM_MMC_CTRL_OSCM24		(0x0 << 24)
+#define CCM_MMC_CTRL_PLL6		(0x1 << 24)
+#define CCM_MMC_CTRL_ENABLE		(0x1 << 31)
+
+#define CCM_SATA_CTRL_ENABLE		(0x1 << 31)
+#define CCM_SATA_CTRL_USE_EXTCLK	(0x1 << 24)
+
+#define CCM_USB_CTRL_PHY0_RST (0x1 << 0)
+#define CCM_USB_CTRL_PHY1_RST (0x1 << 1)
+#define CCM_USB_CTRL_PHY2_RST (0x1 << 2)
+#define CCM_USB_CTRL_PHY3_RST (0x1 << 3)
+/* There is no global phy clk gate on SUNIV, define as 0 */
+#define CCM_USB_CTRL_PHYGATE 0
+#define CCM_USB_CTRL_PHY0_CLK (0x1 << 8)
+#define CCM_USB_CTRL_PHY1_CLK (0x1 << 9)
+#define CCM_USB_CTRL_PHY2_CLK (0x1 << 10)
+#define CCM_USB_CTRL_PHY3_CLK (0x1 << 11)
+#ifdef CONFIG_MACH_SUNXI_H3_H5
+#define CCM_USB_CTRL_OHCI0_CLK (0x1 << 16)
+#define CCM_USB_CTRL_OHCI1_CLK (0x1 << 17)
+#define CCM_USB_CTRL_OHCI2_CLK (0x1 << 18)
+#define CCM_USB_CTRL_OHCI3_CLK (0x1 << 19)
+#else
+#define CCM_USB_CTRL_OHCI0_CLK (0x1 << 16)
+#define CCM_USB_CTRL_OHCI1_CLK (0x1 << 17)
+#endif
+
+#define CCM_GMAC_CTRL_TX_CLK_SRC_MII	0x0
+#define CCM_GMAC_CTRL_TX_CLK_SRC_EXT_RGMII 0x1
+#define CCM_GMAC_CTRL_TX_CLK_SRC_INT_RGMII 0x2
+#define CCM_GMAC_CTRL_GPIT_MII		(0x0 << 2)
+#define CCM_GMAC_CTRL_GPIT_RGMII	(0x1 << 2)
+#define CCM_GMAC_CTRL_RX_CLK_DELAY(x)	((x) << 5)
+#define CCM_GMAC_CTRL_TX_CLK_DELAY(x)	((x) << 10)
+
+#define MDFS_CLK_DEFAULT		0x81000002 /* PLL6 / 3 */
+
+#define CCM_DRAMCLK_CFG_DIV(x)		((x - 1) << 0)
+#define CCM_DRAMCLK_CFG_DIV_MASK	(0xf << 0)
+#define CCM_DRAMCLK_CFG_DIV0(x)		((x - 1) << 8)
+#define CCM_DRAMCLK_CFG_DIV0_MASK	(0xf << 8)
+#define CCM_DRAMCLK_CFG_SRC_PLL5	(0x0 << 20)
+#define CCM_DRAMCLK_CFG_SRC_PLL6x2	(0x1 << 20)
+#define CCM_DRAMCLK_CFG_SRC_PLL11	(0x1 << 20) /* A64 only */
+#define CCM_DRAMCLK_CFG_SRC_MASK	(0x3 << 20)
+#define CCM_DRAMCLK_CFG_UPD		(0x1 << 16)
+#define CCM_DRAMCLK_CFG_RST		(0x1 << 31)
+
+#define CCM_DRAMPLL_CFG_SRC_PLL5	(0x0 << 16) /* Select PLL5 (DDR0) */
+#define CCM_DRAMPLL_CFG_SRC_PLL11	(0x1 << 16) /* Select PLL11 (DDR1) */
+#define CCM_DRAMPLL_CFG_SRC_MASK	(0x1 << 16)
+
+#define CCM_MBUS_RESET_RESET		(0x1 << 31)
+
+#define CCM_DRAM_GATE_OFFSET_DE_FE0	24
+#define CCM_DRAM_GATE_OFFSET_DE_FE1	25
+#define CCM_DRAM_GATE_OFFSET_DE_BE0	26
+#define CCM_DRAM_GATE_OFFSET_DE_BE1	27
+
+#define CCM_LCD_CH0_CTRL_PLL3		(0 << 24)
+#define CCM_LCD_CH0_CTRL_PLL7		(1 << 24)
+#define CCM_LCD_CH0_CTRL_PLL3_2X	(2 << 24)
+#define CCM_LCD_CH0_CTRL_PLL7_2X	(3 << 24)
+#define CCM_LCD_CH0_CTRL_MIPI_PLL	(4 << 24)
+/* No reset bit in ch0_clk_cfg (reset is controlled through ahb_reset1) */
+#define CCM_LCD_CH0_CTRL_RST		0
+#define CCM_LCD_CH0_CTRL_GATE		(0x1 << 31)
+
+#define CCM_LCD_CH1_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_LCD_CH1_CTRL_HALF_SCLK1	0 /* no seperate sclk1 & 2 on SUNIV */
+#define CCM_LCD_CH1_CTRL_PLL3		(0 << 24)
+#define CCM_LCD_CH1_CTRL_PLL7		(1 << 24)
+#define CCM_LCD_CH1_CTRL_PLL3_2X	(2 << 24)
+#define CCM_LCD_CH1_CTRL_PLL7_2X	(3 << 24)
+#define CCM_LCD_CH1_CTRL_GATE		(0x1 << 31)
+
+#define CCM_LCD0_CTRL_GATE		(0x1 << 31)
+#define CCM_LCD0_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+
+#define CCM_LCD1_CTRL_GATE		(0x1 << 31)
+#define CCM_LCD1_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+
+#define CCM_HDMI_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_HDMI_CTRL_PLL_MASK		(3 << 24)
+#define CCM_HDMI_CTRL_PLL3		(0 << 24)
+#define CCM_HDMI_CTRL_PLL7		(1 << 24)
+#define CCM_HDMI_CTRL_PLL3_2X		(2 << 24)
+#define CCM_HDMI_CTRL_PLL7_2X		(3 << 24)
+#define CCM_HDMI_CTRL_DDC_GATE		(0x1 << 30)
+#define CCM_HDMI_CTRL_GATE		(0x1 << 31)
+
+#define CCM_HDMI_SLOW_CTRL_DDC_GATE	(1 << 31)
+
+#define CCM_TVE_CTRL_GATE		(0x1 << 31)
+#define CCM_TVE_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+
+#if defined(CONFIG_MACH_SUN50I)
+#define MBUS_CLK_DEFAULT		0x81000002 /* PLL6x2 / 3 */
+#elif defined(CONFIG_MACH_SUN8I)
+#define MBUS_CLK_DEFAULT		0x81000003 /* PLL6 / 4 */
+#else
+#define MBUS_CLK_DEFAULT		0x81000001 /* PLL6 / 2 */
+#endif
+#define MBUS_CLK_GATE			(0x1 << 31)
+
+#define CCM_PLL5_PATTERN		0xd1303333
+#define CCM_PLL11_PATTERN		0xf5860000
+
+/* ahb_reset0 offsets */
+#ifdef CONFIG_MACH_SUN8I_R40
+#define AHB_RESET_OFFSET_SATA		24
+#endif
+#define AHB_RESET_OFFSET_SPI1		21
+#define AHB_RESET_OFFSET_SPI0		20
+#define AHB_RESET_OFFSET_GMAC		17
+#define AHB_RESET_OFFSET_MCTL		14
+#define AHB_RESET_OFFSET_MMC3		11
+#define AHB_RESET_OFFSET_MMC2		10
+#define AHB_RESET_OFFSET_MMC1		9
+#define AHB_RESET_OFFSET_MMC0		8
+#define AHB_RESET_OFFSET_MMC(n)		(AHB_RESET_OFFSET_MMC0 + (n))
+#define AHB_RESET_OFFSET_SS		5
+
+/* ahb_reset1 offsets */
+#define AHB_RESET_OFFSET_SAT		26
+#define AHB_RESET_OFFSET_DRC0		25
+#define AHB_RESET_OFFSET_DE_FE0		14
+#define AHB_RESET_OFFSET_DE_BE0		12
+#define AHB_RESET_OFFSET_DE		12
+#define AHB_RESET_OFFSET_HDMI		11
+#define AHB_RESET_OFFSET_HDMI2		10
+#define AHB_RESET_OFFSET_TVE		9
+#ifndef CONFIG_SUNXI_DE2
+#define AHB_RESET_OFFSET_LCD1		5
+#define AHB_RESET_OFFSET_LCD0		4
+#else
+#define AHB_RESET_OFFSET_LCD1		4
+#define AHB_RESET_OFFSET_LCD0		3
+#endif
+
+/* ahb_reset2 offsets */
+#define AHB_RESET_OFFSET_EPHY		2
+#define AHB_RESET_OFFSET_LVDS		0
+
+/* apb1 reset */
+#ifdef CONFIG_MACH_SUNIV
+#define APB1_RESET_UART_SHIFT	(20)
+#define APB1_RESET_UART_MASK		(0x7 << APB1_RESET_UART_SHIFT)
+#define APB1_RESET_TWI_SHIFT	(16)
+#define APB1_RESET_TWI_MASK		(0x7 << APB1_RESET_TWI_SHIFT)
+#endif
+
+/* apb2 reset */
+#define APB2_RESET_UART_SHIFT		(16)
+#define APB2_RESET_UART_MASK		(0xff << APB2_RESET_UART_SHIFT)
+#define APB2_RESET_TWI_SHIFT		(0)
+#define APB2_RESET_TWI_MASK		(0xf << APB2_RESET_TWI_SHIFT)
+
+/* CCM bits common to all Display Engine (and IEP) clock ctrl regs */
+#define CCM_DE_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_DE_CTRL_PLL_MASK		(0xf << 24)
+#define CCM_DE_CTRL_PLL3		(0 << 24)
+#define CCM_DE_CTRL_PLL7		(1 << 24)
+#define CCM_DE_CTRL_PLL6_2X		(2 << 24)
+#define CCM_DE_CTRL_PLL8		(3 << 24)
+#define CCM_DE_CTRL_PLL9		(4 << 24)
+#define CCM_DE_CTRL_PLL10		(5 << 24)
+#define CCM_DE_CTRL_GATE		(1 << 31)
+
+/* CCM bits common to all Display Engine 2.0 clock ctrl regs */
+#define CCM_DE2_CTRL_M(n)		((((n) - 1) & 0xf) << 0)
+#define CCM_DE2_CTRL_PLL_MASK		(3 << 24)
+#define CCM_DE2_CTRL_PLL6_2X		(0 << 24)
+#define CCM_DE2_CTRL_PLL10		(1 << 24)
+#define CCM_DE2_CTRL_GATE		(0x1 << 31)
+
+/* CCU security switch, H3 only */
+#define CCM_SEC_SWITCH_MBUS_NONSEC	(1 << 2)
+#define CCM_SEC_SWITCH_BUS_NONSEC	(1 << 1)
+#define CCM_SEC_SWITCH_PLL_NONSEC	(1 << 0)
+
+#ifndef __ASSEMBLY__
+void clock_set_pll1(unsigned int hz);
+void clock_set_pll3(unsigned int hz);
+void clock_set_pll3_factors(int m, int n);
+void clock_set_pll5(unsigned int clk, bool sigma_delta_enable);
+void clock_set_pll10(unsigned int hz);
+void clock_set_pll11(unsigned int clk, bool sigma_delta_enable);
+void clock_set_mipi_pll(unsigned int hz);
+unsigned int clock_get_pll3(void);
+unsigned int clock_get_pll6(void);
+unsigned int clock_get_mipi_pll(void);
+#endif
+
+#endif /* _SUNXI_CLOCK_SUNIV_H */
diff --git a/arch/arm/include/asm/arch-sunxi/cpu.h b/arch/arm/include/asm/arch-sunxi/cpu.h
index 4c399b0a..bb8db511 100644
--- a/arch/arm/include/asm/arch-sunxi/cpu.h
+++ b/arch/arm/include/asm/arch-sunxi/cpu.h
@@ -10,6 +10,8 @@
 #include <asm/arch/cpu_sun9i.h>
 #elif defined(CONFIG_MACH_SUN50I_H6)
 #include <asm/arch/cpu_sun50i_h6.h>
+#elif defined(CONFIG_MACH_SUNIV)
+#include <asm/arch/cpu_suniv.h>
 #else
 #include <asm/arch/cpu_sun4i.h>
 #endif
diff --git a/arch/arm/include/asm/arch-sunxi/cpu_suniv.h b/arch/arm/include/asm/arch-sunxi/cpu_suniv.h
new file mode 100644
index 00000000..c8a1a82c
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/cpu_suniv.h
@@ -0,0 +1,232 @@
+/* SPDX-License-Identifier: GPL-2.0+ */
+/*
+ * (C) Copyright 2007-2011
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ */
+
+#ifndef _SUNXI_CPU_SUNIV_H
+#define _SUNXI_CPU_SUNIV_H
+
+#define SUNXI_SRAM_A1_BASE		0x00000000
+#define SUNXI_SRAM_A1_SIZE		(16 * 1024)	/* 16 kiB */
+
+#define SUNXI_SRAM_A2_BASE		0x00004000	/* 16 kiB */
+#define SUNXI_SRAM_A3_BASE		0x00008000	/* 13 kiB */
+#define SUNXI_SRAM_A4_BASE		0x0000b400	/* 3 kiB */
+#define SUNXI_SRAM_D_BASE		0x00010000	/* 4 kiB */
+#define SUNXI_SRAM_B_BASE		0x00020000	/* 64 kiB (secure) */
+
+#define SUNXI_DE2_BASE			0x01000000
+
+#ifdef CONFIG_MACH_SUN8I_A83T
+#define SUNXI_CPUCFG_BASE		0x01700000
+#endif
+
+#define SUNXI_SRAMC_BASE		0x01c00000
+#define SUNXI_DRAMC_BASE		0x01c01000
+#define SUNXI_DMA_BASE			0x01c02000
+#define SUNXI_NFC_BASE			0x01c03000
+#define SUNXI_TS_BASE			0x01c04000
+#define SUNXI_SPI0_BASE			0x01c05000
+#define SUNXI_SPI1_BASE			0x01c06000
+#define SUNXI_MS_BASE			0x01c07000
+#define SUNXI_TVD_BASE			0x01c08000
+#define SUNXI_CSI0_BASE			0x01c09000
+#ifndef CONFIG_MACH_SUNXI_H3_H5
+#define SUNXI_TVE0_BASE			0x01c0a000
+#endif
+#define SUNXI_EMAC_BASE			0x01c0b000
+#define SUNXI_LCD0_BASE			0x01c0C000
+#define SUNXI_LCD1_BASE			0x01c0d000
+#define SUNXI_VE_BASE			0x01c0e000
+#define SUNXI_MMC0_BASE			0x01c0f000
+#define SUNXI_MMC1_BASE			0x01c10000
+#ifndef CONFIG_MACH_SUNIV
+#define SUNXI_MMC2_BASE			0x01c11000
+#else
+#define SUNXI_MMC2_BASE			0x01c10000
+#endif
+#define SUNXI_MMC3_BASE			0x01c12000
+#ifdef CONFIG_SUNXI_GEN_SUNIV
+#define SUNXI_USB0_BASE			0x01c13000
+#define SUNXI_USB1_BASE			0x01c14000
+#endif
+#define SUNXI_SS_BASE			0x01c15000
+#if !defined(CONFIG_MACH_SUNXI_H3_H5) && !defined(CONFIG_MACH_SUN50I)
+#define SUNXI_HDMI_BASE			0x01c16000
+#endif
+#define SUNXI_SPI2_BASE			0x01c17000
+#define SUNXI_SATA_BASE			0x01c18000
+#ifdef CONFIG_SUNXI_GEN_SUNIV
+#define SUNXI_PATA_BASE			0x01c19000
+#define SUNXI_ACE_BASE			0x01c1a000
+#define SUNXI_TVE1_BASE			0x01c1b000
+#define SUNXI_USB2_BASE			0x01c1c000
+#endif
+#ifdef CONFIG_SUNXI_GEN_SUN6I
+#if defined(CONFIG_MACH_SUNXI_H3_H5) || defined(CONFIG_MACH_SUN50I)
+#define SUNXI_USBPHY_BASE		0x01c19000
+#define SUNXI_USB0_BASE			SUNXI_USBPHY_BASE
+#define SUNXI_USB1_BASE			0x01c1a000
+#define SUNXI_USB2_BASE			0x01c1b000
+#define SUNXI_USB3_BASE			0x01c1c000
+#define SUNXI_USB4_BASE			0x01c1d000
+#else
+#define SUNXI_USB0_BASE			0x01c19000
+#define SUNXI_USB1_BASE			0x01c1a000
+#define SUNXI_USB2_BASE			0x01c1b000
+#endif
+#endif
+#define SUNXI_CSI1_BASE			0x01c1d000
+#define SUNXI_TZASC_BASE		0x01c1e000
+#define SUNXI_SPI3_BASE			0x01c1f000
+
+#define SUNXI_CCM_BASE			0x01c20000
+#define SUNXI_INTC_BASE			0x01c20400
+#define SUNXI_PIO_BASE			0x01c20800
+#define SUNXI_TIMER_BASE		0x01c20c00
+#ifndef CONFIG_SUNXI_GEN_SUN6I
+#define SUNXI_PWM_BASE			0x01c20e00
+#endif
+#define SUNXI_SPDIF_BASE		0x01c21000
+#ifdef CONFIG_SUNXI_GEN_SUN6I
+#define SUNXI_PWM_BASE			0x01c21400
+#else
+#define SUNXI_AC97_BASE			0x01c21400
+#endif
+#define SUNXI_IR0_BASE			0x01c21800
+#define SUNXI_IR1_BASE			0x01c21c00
+
+#define SUNXI_IIS_BASE			0x01c22400
+#define SUNXI_LRADC_BASE		0x01c22800
+#define SUNXI_AD_DA_BASE		0x01c22c00
+#define SUNXI_KEYPAD_BASE		0x01c23000
+#define SUNXI_TZPC_BASE			0x01c23400
+
+#if defined(CONFIG_MACH_SUN8I_A83T) || defined(CONFIG_MACH_SUNXI_H3_H5) || \
+defined(CONFIG_MACH_SUN50I)
+/* SID address space starts at 0x01c1400, but e-fuse is at offset 0x200 */
+#define SUNXI_SIDC_BASE			0x01c14000
+#define SUNXI_SID_BASE			0x01c14200
+#else
+#define SUNXI_SID_BASE			0x01c23800
+#endif
+
+#define SUNXI_SJTAG_BASE		0x01c23c00
+
+#ifdef CONFIG_MACH_SUNIV
+#define SUNXI_UART0_BASE		0x01c25000
+#define SUNXI_UART1_BASE		0x01c25400
+#define SUNXI_UART2_BASE		0x01c25800
+#endif
+
+#define SUNXI_TP_BASE			0x01c25000
+#define SUNXI_PMU_BASE			0x01c25400
+
+#if defined CONFIG_MACH_SUN7I || defined CONFIG_MACH_SUN8I_R40
+#define SUNXI_CPUCFG_BASE		0x01c25c00
+#endif
+
+#ifndef CONFIG_MACH_SUNIV
+#define SUNXI_UART0_BASE		0x01c28000
+#define SUNXI_UART1_BASE		0x01c28400
+#define SUNXI_UART2_BASE		0x01c28800
+#endif
+#define SUNXI_UART3_BASE		0x01c28c00
+#define SUNXI_UART4_BASE		0x01c29000
+#define SUNXI_UART5_BASE		0x01c29400
+#define SUNXI_UART6_BASE		0x01c29800
+#define SUNXI_UART7_BASE		0x01c29c00
+#define SUNXI_PS2_0_BASE		0x01c2a000
+#define SUNXI_PS2_1_BASE		0x01c2a400
+
+#define SUNXI_TWI0_BASE			0x01c2ac00
+#define SUNXI_TWI1_BASE			0x01c2b000
+#define SUNXI_TWI2_BASE			0x01c2b400
+#ifdef CONFIG_MACH_SUN6I
+#define SUNXI_TWI3_BASE			0x01c0b800
+#endif
+#ifdef CONFIG_MACH_SUN7I
+#define SUNXI_TWI3_BASE			0x01c2b800
+#define SUNXI_TWI4_BASE			0x01c2c000
+#endif
+
+#define SUNXI_CAN_BASE			0x01c2bc00
+
+#define SUNXI_SCR_BASE			0x01c2c400
+
+#ifndef CONFIG_MACH_SUN6I
+#define SUNXI_GPS_BASE			0x01c30000
+#define SUNXI_MALI400_BASE		0x01c40000
+#define SUNXI_GMAC_BASE			0x01c50000
+#else
+#define SUNXI_GMAC_BASE			0x01c30000
+#endif
+
+#define SUNXI_DRAM_COM_BASE		0x01c62000
+#define SUNXI_DRAM_CTL0_BASE		0x01c63000
+#define SUNXI_DRAM_CTL1_BASE		0x01c64000
+#define SUNXI_DRAM_PHY0_BASE		0x01c65000
+#define SUNXI_DRAM_PHY1_BASE		0x01c66000
+
+#define SUNXI_GIC400_BASE		0x01c80000
+
+/* module sram */
+#define SUNXI_SRAM_C_BASE		0x01d00000
+
+#ifndef CONFIG_MACH_SUN8I_H3
+#define SUNXI_DE_FE0_BASE		0x01e00000
+#else
+#define SUNXI_TVE0_BASE			0x01e00000
+#endif
+#define SUNXI_DE_FE1_BASE		0x01e20000
+#define SUNXI_DE_BE0_BASE		0x01e60000
+#ifndef CONFIG_MACH_SUN50I_H5
+#define SUNXI_DE_BE1_BASE		0x01e40000
+#else
+#define SUNXI_TVE0_BASE			0x01e40000
+#endif
+#define SUNXI_MP_BASE			0x01e80000
+#define SUNXI_AVG_BASE			0x01ea0000
+
+#if defined(CONFIG_MACH_SUNXI_H3_H5) || defined(CONFIG_MACH_SUN50I)
+#define SUNXI_HDMI_BASE			0x01ee0000
+#endif
+
+#define SUNXI_RTC_BASE			0x01f00000
+#define SUNXI_PRCM_BASE			0x01f01400
+
+#if defined CONFIG_SUNXI_GEN_SUN6I && \
+    !defined CONFIG_MACH_SUN8I_A83T && \
+    !defined CONFIG_MACH_SUN8I_R40
+#define SUNXI_CPUCFG_BASE		0x01f01c00
+#endif
+
+#define SUNXI_R_TWI_BASE		0x01f02400
+#define SUNXI_R_UART_BASE		0x01f02800
+#define SUNXI_R_PIO_BASE		0x01f02c00
+#define SUN6I_P2WI_BASE			0x01f03400
+#define SUNXI_RSB_BASE			0x01f03400
+
+/* CoreSight Debug Module */
+#define SUNXI_CSDM_BASE			0x3f500000
+
+#define SUNXI_DDRII_DDRIII_BASE		0x40000000	/* 2 GiB */
+
+#define SUNXI_BROM_BASE			0xffff0000	/* 32 kiB */
+
+#define SUNXI_CPU_CFG			(SUNXI_TIMER_BASE + 0x13c)
+
+/* SS bonding ids used for cpu identification */
+#define SUNXI_SS_BOND_ID_A31		4
+#define SUNXI_SS_BOND_ID_A31S		5
+
+#ifndef __ASSEMBLY__
+void sunxi_board_init(void);
+void sunxi_reset(void);
+int sunxi_get_ss_bonding_id(void);
+int sunxi_get_sid(unsigned int *sid);
+#endif /* __ASSEMBLY__ */
+
+#endif /* _SUNXI_CPU_SUNIV_H */
diff --git a/arch/arm/include/asm/arch-sunxi/dram.h b/arch/arm/include/asm/arch-sunxi/dram.h
index 8002b7ef..523dd71c 100644
--- a/arch/arm/include/asm/arch-sunxi/dram.h
+++ b/arch/arm/include/asm/arch-sunxi/dram.h
@@ -29,6 +29,8 @@
 #include <asm/arch/dram_sun9i.h>
 #elif defined(CONFIG_MACH_SUN50I_H6)
 #include <asm/arch/dram_sun50i_h6.h>
+#elif defined(CONFIG_MACH_SUNIV)
+#include <asm/arch/dram_suniv.h>
 #else
 #include <asm/arch/dram_sun4i.h>
 #endif
diff --git a/arch/arm/include/asm/arch-sunxi/dram_suniv.h b/arch/arm/include/asm/arch-sunxi/dram_suniv.h
new file mode 100644
index 00000000..60488b08
--- /dev/null
+++ b/arch/arm/include/asm/arch-sunxi/dram_suniv.h
@@ -0,0 +1,53 @@
+/*
+ * suniv DRAM controller register definition
+ *
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Based on xboot's arch/arm32/mach-f1c100s/sys-dram.c, which is:
+ *
+ * Copyright(c) 2007-2018 Jianjun Jiang <8192542@qq.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#ifndef _SUNXI_DRAM_SUNIV_H
+#define _SUNXI_DRAM_SUNIV_H
+
+#define PIO_SDRAM_DRV			(0x2c0)
+#define PIO_SDRAM_PULL			(0x2c4)
+
+#define DRAM_SCONR			(0x00)
+#define DRAM_STMG0R			(0x04)
+#define DRAM_STMG1R			(0x08)
+#define DRAM_SCTLR			(0x0c)
+#define DRAM_SREFR			(0x10)
+#define DRAM_SEXTMR			(0x14)
+#define DRAM_DDLYR			(0x24)
+#define DRAM_DADRR			(0x28)
+#define DRAM_DVALR			(0x2c)
+#define DRAM_DRPTR0			(0x30)
+#define DRAM_DRPTR1			(0x34)
+#define DRAM_DRPTR2			(0x38)
+#define DRAM_DRPTR3			(0x3c)
+#define DRAM_SEFR			(0x40)
+#define DRAM_MAE			(0x44)
+#define DRAM_ASPR			(0x48)
+#define DRAM_SDLY0			(0x4C)
+#define DRAM_SDLY1			(0x50)
+#define DRAM_SDLY2			(0x54)
+#define DRAM_MCR0			(0x100)
+#define DRAM_MCR1			(0x104)
+#define DRAM_MCR2			(0x108)
+#define DRAM_MCR3			(0x10c)
+#define DRAM_MCR4			(0x110)
+#define DRAM_MCR5			(0x114)
+#define DRAM_MCR6			(0x118)
+#define DRAM_MCR7			(0x11c)
+#define DRAM_MCR8			(0x120)
+#define DRAM_MCR9			(0x124)
+#define DRAM_MCR10			(0x128)
+#define DRAM_MCR11			(0x12c)
+#define DRAM_BWCR			(0x140)
+
+#ifndef _SUNXI_DRAM_SUNIV_H
+#define _SUNXI_DRAM_SUNIV_H
\ No newline at end of file
diff --git a/arch/arm/include/asm/arch-sunxi/gpio.h b/arch/arm/include/asm/arch-sunxi/gpio.h
index a646ea6a..030fce7f 100644
--- a/arch/arm/include/asm/arch-sunxi/gpio.h
+++ b/arch/arm/include/asm/arch-sunxi/gpio.h
@@ -169,6 +169,7 @@ enum sunxi_gpio_number {
 #define SUNXI_GPC_NAND		2
 #define SUNXI_GPC_SPI0		3
 #define SUNXI_GPC_SDC2		3
+#define SUNIV_GPC_SPI0		2
 #define SUN6I_GPC_SDC3		4
 #define SUN50I_GPC_SPI0		4
 
@@ -177,6 +178,8 @@ enum sunxi_gpio_number {
 #define SUNXI_GPD_LVDS0		3
 #define SUNXI_GPD_PWM		2
 
+#define SUNIV_GPE_UART0		5
+#define SUNIV_GPE_UART2		3
 #define SUN5I_GPE_SDC2		3
 #define SUN8I_GPE_TWI2		3
 #define SUN50I_GPE_TWI2		3
diff --git a/arch/arm/mach-sunxi/Kconfig b/arch/arm/mach-sunxi/Kconfig
index be0822bf..3e0c529c 100644
--- a/arch/arm/mach-sunxi/Kconfig
+++ b/arch/arm/mach-sunxi/Kconfig
@@ -1,7 +1,8 @@
 if ARCH_SUNXI
 
 config SPL_LDSCRIPT
-	default "arch/arm/cpu/armv7/sunxi/u-boot-spl.lds" if !ARM64
+	default "arch/arm/cpu/arm926ejs/sunxi/u-boot-spl.lds" if MACH_SUNIV
+	default "arch/arm/cpu/armv7/sunxi/u-boot-spl.lds" if !ARM64 && !MACH_SUNIV
 
 config IDENT_STRING
 	default " Allwinner Technology"
diff --git a/arch/arm/mach-sunxi/Makefile b/arch/arm/mach-sunxi/Makefile
index d129f334..aa756ea0 100644
--- a/arch/arm/mach-sunxi/Makefile
+++ b/arch/arm/mach-sunxi/Makefile
@@ -27,6 +27,7 @@ obj-$(CONFIG_MACH_SUN8I)	+= clock_sun6i.o
 endif
 obj-$(CONFIG_MACH_SUN9I)	+= clock_sun9i.o gtbus_sun9i.o
 obj-$(CONFIG_MACH_SUN50I_H6)	+= clock_sun50i_h6.o
+obj-$(CONFIG_MACH_SUNIV)	+= clock_suniv.o
 
 ifdef CONFIG_SPL_BUILD
 obj-$(CONFIG_DRAM_SUN4I)	+= dram_sun4i.o
@@ -40,4 +41,5 @@ obj-$(CONFIG_SUNXI_DRAM_DW)	+= dram_sunxi_dw.o
 obj-$(CONFIG_SUNXI_DRAM_DW)	+= dram_timings/
 obj-$(CONFIG_DRAM_SUN50I_H6)	+= dram_sun50i_h6.o
 obj-$(CONFIG_DRAM_SUN50I_H6)	+= dram_timings/
+obj-$(CONFIG_MACH_SUNIV)	+= dram_suniv.o
 endif
diff --git a/arch/arm/mach-sunxi/board.c b/arch/arm/mach-sunxi/board.c
index f40fccd8..ee41f534 100644
--- a/arch/arm/mach-sunxi/board.c
+++ b/arch/arm/mach-sunxi/board.c
@@ -78,7 +78,8 @@ static int gpio_init(void)
 	sunxi_gpio_set_cfgpin(SUNXI_GPB(22), SUNXI_GPIO_INPUT);
 	sunxi_gpio_set_cfgpin(SUNXI_GPB(23), SUNXI_GPIO_INPUT);
 #endif
-#if defined(CONFIG_MACH_SUN8I) && !defined(CONFIG_MACH_SUN8I_R40)
+#if (defined(CONFIG_MACH_SUN8I) && !defined(CONFIG_MACH_SUN8I_R40)) || \
+    defined(CONFIG_MACH_SUNIV)
 	sunxi_gpio_set_cfgpin(SUNXI_GPF(2), SUN8I_GPF_UART0);
 	sunxi_gpio_set_cfgpin(SUNXI_GPF(4), SUN8I_GPF_UART0);
 #else
@@ -86,6 +87,10 @@ static int gpio_init(void)
 	sunxi_gpio_set_cfgpin(SUNXI_GPF(4), SUNXI_GPF_UART0);
 #endif
 	sunxi_gpio_set_pull(SUNXI_GPF(4), 1);
+#elif CONFIG_CONS_INDEX == 1 && defined(CONFIG_MACH_SUNIV)
+	sunxi_gpio_set_cfgpin(SUNXI_GPE(0), SUNIV_GPE_UART0);
+	sunxi_gpio_set_cfgpin(SUNXI_GPE(1), SUNIV_GPE_UART0);
+	sunxi_gpio_set_pull(SUNXI_GPE(1), SUNXI_GPIO_PULL_UP);
 #elif CONFIG_CONS_INDEX == 1 && (defined(CONFIG_MACH_SUN4I) || \
 				 defined(CONFIG_MACH_SUN7I) || \
 				 defined(CONFIG_MACH_SUN8I_R40))
@@ -132,10 +137,18 @@ static int gpio_init(void)
 	sunxi_gpio_set_cfgpin(SUNXI_GPG(3), SUN5I_GPG_UART1);
 	sunxi_gpio_set_cfgpin(SUNXI_GPG(4), SUN5I_GPG_UART1);
 	sunxi_gpio_set_pull(SUNXI_GPG(4), SUNXI_GPIO_PULL_UP);
+#elif CONFIG_CONS_INDEX == 2 && defined(CONFIG_MACH_SUNIV)
+	sunxi_gpio_set_cfgpin(SUNXI_GPA(2), SUNIV_GPE_UART0);
+	sunxi_gpio_set_cfgpin(SUNXI_GPA(3), SUNIV_GPE_UART0);
+	sunxi_gpio_set_pull(SUNXI_GPA(3), SUNXI_GPIO_PULL_UP);
 #elif CONFIG_CONS_INDEX == 3 && defined(CONFIG_MACH_SUN8I)
 	sunxi_gpio_set_cfgpin(SUNXI_GPB(0), SUN8I_GPB_UART2);
 	sunxi_gpio_set_cfgpin(SUNXI_GPB(1), SUN8I_GPB_UART2);
 	sunxi_gpio_set_pull(SUNXI_GPB(1), SUNXI_GPIO_PULL_UP);
+#elif CONFIG_CONS_INDEX == 3 && defined(CONFIG_MACH_SUNIV)
+	sunxi_gpio_set_cfgpin(SUNXI_GPE(7), SUNIV_GPE_UART2);
+	sunxi_gpio_set_cfgpin(SUNXI_GPE(8), SUNIV_GPE_UART2);
+	sunxi_gpio_set_pull(SUNXI_GPE(7), SUNXI_GPIO_PULL_UP);
 #elif CONFIG_CONS_INDEX == 5 && defined(CONFIG_MACH_SUN8I)
 	sunxi_gpio_set_cfgpin(SUNXI_GPL(2), SUN8I_GPL_R_UART);
 	sunxi_gpio_set_cfgpin(SUNXI_GPL(3), SUN8I_GPL_R_UART);
@@ -202,7 +215,8 @@ void s_init(void)
 	/* No H3 BSP, boot0 seems to not modify SUNXI_SRAMC_BASE + 0x44 */
 #endif
 
-#if !defined(CONFIG_ARM_CORTEX_CPU_IS_UP) && !defined(CONFIG_ARM64)
+#if !defined(CONFIG_ARM_CORTEX_CPU_IS_UP) && !defined(CONFIG_ARM64) && \
+	!defined(CONFIG_MACH_SUNIV)
 	/* Enable SMP mode for CPU0, by setting bit 6 of Auxiliary Ctl reg */
 	asm volatile(
 		"mrc p15, 0, r0, c1, c0, 1\n"
@@ -226,6 +240,12 @@ void s_init(void)
 
 #define SUNXI_INVALID_BOOT_SOURCE	-1
 
+#ifdef CONFIG_MACH_SUNIV
+static int sunxi_get_boot_source(void)
+{
+	return (s8)readb(SPL_ADDR + 0x6fff);
+}
+#else
 static int sunxi_get_boot_source(void)
 {
 	if (!is_boot0_magic(SPL_ADDR + 4)) /* eGON.BT0 */
@@ -233,7 +253,7 @@ static int sunxi_get_boot_source(void)
 
 	return readb(SPL_ADDR + 0x28);
 }
-
+#endif
 /* The sunxi internal brom will try to loader external bootloader
  * from mmc0, nand flash, mmc2.
  */
@@ -297,10 +317,32 @@ unsigned long spl_mmc_get_uboot_raw_sector(struct mmc *mmc)
 	return sector;
 }
 
+#ifndef CONFIG_MACH_SUNIV
 u32 spl_boot_device(void)
 {
 	return sunxi_get_boot_device();
 }
+#else
+/*
+ * suniv BROM do not pass the boot media type to SPL, so we try with the
+ * boot sequence in BROM: mmc0->spinor->fail.
+ */
+void board_boot_order(u32 *spl_boot_list)
+{
+	/*
+	 * See the comments above in sunxi_get_boot_device() for infomation
+	 * about FEL boot.
+	 */
+	if (!is_boot0_magic(SPL_ADDR + 4)) {
+		spl_boot_list[0] = BOOT_DEVICE_BOARD;
+		return;
+	}
+
+	spl_boot_list[0] = BOOT_DEVICE_MMC1;
+	spl_boot_list[1] = BOOT_DEVICE_MMC2;
+	spl_boot_list[2] = BOOT_DEVICE_SPI;
+}
+#endif
 
 void board_init_f(ulong dummy)
 {
@@ -346,7 +388,7 @@ void reset_cpu(ulong addr)
 #endif
 }
 
-#if !CONFIG_IS_ENABLED(SYS_DCACHE_OFF) && !defined(CONFIG_ARM64)
+#if !CONFIG_IS_ENABLED(SYS_DCACHE_OFF) && !defined(CONFIG_ARM64) && !defined(CONFIG_MACH_SUNIV)
 void enable_caches(void)
 {
 	/* Enable D-cache. I-cache is already enabled in start.S */
diff --git a/arch/arm/mach-sunxi/clock.c b/arch/arm/mach-sunxi/clock.c
index f591affe..636b3b6b 100644
--- a/arch/arm/mach-sunxi/clock.c
+++ b/arch/arm/mach-sunxi/clock.c
@@ -36,7 +36,8 @@ int clock_init(void)
 }
 
 /* These functions are shared between various SoCs so put them here. */
-#if defined CONFIG_SUNXI_GEN_SUN6I && !defined CONFIG_MACH_SUN9I
+#if defined CONFIG_SUNXI_GEN_SUN6I && !defined CONFIG_MACH_SUN9I && \
+	!defined CONFIG_MACH_SUNIV
 int clock_twi_onoff(int port, int state)
 {
 	struct sunxi_ccm_reg *const ccm =
diff --git a/arch/arm/mach-sunxi/clock_suniv.c b/arch/arm/mach-sunxi/clock_suniv.c
new file mode 100644
index 00000000..6bd94f0a
--- /dev/null
+++ b/arch/arm/mach-sunxi/clock_suniv.c
@@ -0,0 +1,392 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * sun6i specific clock code
+ *
+ * (C) Copyright 2007-2012
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Tom Cubie <tangliang@allwinnertech.com>
+ *
+ * (C) Copyright 2013 Luke Kenneth Casson Leighton <lkcl@lkcl.net>
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/prcm.h>
+#include <asm/arch/sys_proto.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+
+#ifdef CONFIG_SPL_BUILD
+void clock_init_safe(void)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+
+#if !defined(CONFIG_MACH_SUNXI_H3_H5) && !defined(CONFIG_MACH_SUN50I) && \
+	!defined(CONFIG_MACH_SUNIV)
+	struct sunxi_prcm_reg * const prcm =
+		(struct sunxi_prcm_reg *)SUNXI_PRCM_BASE;
+
+	/* Set PLL ldo voltage without this PLL6 does not work properly */
+	clrsetbits_le32(&prcm->pll_ctrl1, PRCM_PLL_CTRL_LDO_KEY_MASK,
+			PRCM_PLL_CTRL_LDO_KEY);
+	clrsetbits_le32(&prcm->pll_ctrl1, ~PRCM_PLL_CTRL_LDO_KEY_MASK,
+		PRCM_PLL_CTRL_LDO_DIGITAL_EN | PRCM_PLL_CTRL_LDO_ANALOG_EN |
+		PRCM_PLL_CTRL_EXT_OSC_EN | PRCM_PLL_CTRL_LDO_OUT_L(1140));
+	clrbits_le32(&prcm->pll_ctrl1, PRCM_PLL_CTRL_LDO_KEY_MASK);
+#endif
+
+#if defined(CONFIG_MACH_SUN8I_R40) || defined(CONFIG_MACH_SUN50I)
+	/* Set PLL lock enable bits and switch to old lock mode */
+	writel(GENMASK(12, 0), &ccm->pll_lock_ctrl);
+#endif
+
+	clock_set_pll1(408000000);
+
+	writel(PLL6_CFG_DEFAULT, &ccm->pll6_cfg);
+	while (!(readl(&ccm->pll6_cfg) & CCM_PLL6_CTRL_LOCK))
+		;
+
+	writel(AHB1_ABP1_DIV_DEFAULT, &ccm->ahb1_apb1_div);
+
+#ifndef CONFIG_MACH_SUNIV
+	writel(MBUS_CLK_DEFAULT, &ccm->mbus0_clk_cfg);
+	if (IS_ENABLED(CONFIG_MACH_SUN6I))
+		writel(MBUS_CLK_DEFAULT, &ccm->mbus1_clk_cfg);
+#endif
+
+#if defined(CONFIG_MACH_SUN8I_R40) && defined(CONFIG_SUNXI_AHCI)
+	setbits_le32(&ccm->sata_pll_cfg, CCM_SATA_PLL_DEFAULT);
+	setbits_le32(&ccm->ahb_reset0_cfg, 0x1 << AHB_GATE_OFFSET_SATA);
+	setbits_le32(&ccm->ahb_gate0, 0x1 << AHB_GATE_OFFSET_SATA);
+	setbits_le32(&ccm->sata_clk_cfg, CCM_SATA_CTRL_ENABLE);
+#endif
+}
+#endif
+
+void clock_init_sec(void)
+{
+#ifdef CONFIG_MACH_SUNXI_H3_H5
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	struct sunxi_prcm_reg * const prcm =
+		(struct sunxi_prcm_reg *)SUNXI_PRCM_BASE;
+
+	setbits_le32(&ccm->ccu_sec_switch,
+		     CCM_SEC_SWITCH_MBUS_NONSEC |
+		     CCM_SEC_SWITCH_BUS_NONSEC |
+		     CCM_SEC_SWITCH_PLL_NONSEC);
+	setbits_le32(&prcm->prcm_sec_switch,
+		     PRCM_SEC_SWITCH_APB0_CLK_NONSEC |
+		     PRCM_SEC_SWITCH_PLL_CFG_NONSEC |
+		     PRCM_SEC_SWITCH_PWR_GATE_NONSEC);
+#endif
+}
+
+void clock_init_uart(void)
+{
+#if CONFIG_CONS_INDEX < 5
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+
+#ifndef CONFIG_MACH_SUNIV
+	/* uart clock source is apb2 */
+	writel(APB2_CLK_SRC_OSC24M|
+	       APB2_CLK_RATE_N_1|
+	       APB2_CLK_RATE_M(1),
+	       &ccm->apb2_div);
+
+	/* open the clock for uart */
+	setbits_le32(&ccm->apb2_gate,
+		     CLK_GATE_OPEN << (APB2_GATE_UART_SHIFT +
+				       CONFIG_CONS_INDEX - 1));
+
+	/* deassert uart reset */
+	setbits_le32(&ccm->apb2_reset_cfg,
+		     1 << (APB2_RESET_UART_SHIFT +
+			   CONFIG_CONS_INDEX - 1));
+#else
+	/* suniv doesn't have apb2, so uart clock source is apb1 */
+	writel(PLL6_CFG_DEFAULT, &ccm->pll6_cfg);
+	while (!(readl(&ccm->pll6_cfg) & CCM_PLL6_CTRL_LOCK))
+		;
+
+	writel(AHB1_ABP1_DIV_DEFAULT, &ccm->ahb1_apb1_div);
+
+	/* open the clock for uart */
+	setbits_le32(&ccm->apb1_gate,
+		     CLK_GATE_OPEN << (APB1_GATE_UART_SHIFT +
+				       CONFIG_CONS_INDEX - 1));
+
+	/* deassert uart reset */
+	setbits_le32(&ccm->apb1_reset_cfg,
+		     1 << (APB1_RESET_UART_SHIFT +
+			   CONFIG_CONS_INDEX - 1));
+#endif
+#else
+	/* enable R_PIO and R_UART clocks, and de-assert resets */
+	prcm_apb0_enable(PRCM_APB0_GATE_PIO | PRCM_APB0_GATE_UART);
+#endif
+}
+
+#ifdef CONFIG_SPL_BUILD
+void clock_set_pll1(unsigned int clk)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	const int p = 0;
+	int k = 1;
+	int m = 1;
+
+	if (clk > 1152000000) {
+		k = 2;
+	} else if (clk > 768000000) {
+		k = 4;
+		m = 2;
+	}
+
+	/* Switch to 24MHz clock while changing PLL1 */
+#ifndef CONFIG_MACH_SUNIV
+	writel(AXI_DIV_3 << AXI_DIV_SHIFT |
+	       ATB_DIV_2 << ATB_DIV_SHIFT |
+	       CPU_CLK_SRC_OSC24M << CPU_CLK_SRC_SHIFT,
+	       &ccm->cpu_axi_cfg);
+#else
+	writel(CPU_CLK_SRC_OSC24M << CPU_CLK_SRC_SHIFT,
+	       &ccm->cpu_axi_cfg);
+#endif
+
+	/*
+	 * sun6i: PLL1 rate = ((24000000 * n * k) >> 0) / m   (p is ignored)
+	 * sun8i: PLL1 rate = ((24000000 * n * k) >> p) / m
+	 */
+	writel(CCM_PLL1_CTRL_EN | CCM_PLL1_CTRL_P(p) |
+	       CCM_PLL1_CTRL_N(clk / (24000000 * k / m)) |
+	       CCM_PLL1_CTRL_K(k) | CCM_PLL1_CTRL_M(m), &ccm->pll1_cfg);
+#ifndef CONFIG_MACH_SUNIV
+	sdelay(200);
+#else
+	do {
+		/* ARM926EJ-S code do not have sdelay */
+		volatile int i = 200;
+
+		while (i > 0) i--;
+	} while(0);
+#endif
+
+	/* Switch CPU to PLL1 */
+#ifndef CONFIG_MACH_SUNIV
+	writel(AXI_DIV_3 << AXI_DIV_SHIFT |
+	       ATB_DIV_2 << ATB_DIV_SHIFT |
+	       CPU_CLK_SRC_PLL1 << CPU_CLK_SRC_SHIFT,
+	       &ccm->cpu_axi_cfg);
+#else
+	writel(CPU_CLK_SRC_PLL1 << CPU_CLK_SRC_SHIFT,
+	       &ccm->cpu_axi_cfg);
+#endif
+}
+#endif
+
+void clock_set_pll3(unsigned int clk)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+#ifdef CONFIG_SUNXI_DE2
+	const int m = 4; /* 6 MHz steps to allow higher frequency for DE2 */
+#else
+	const int m = 8; /* 3 MHz steps just like sun4i, sun5i and sun7i */
+#endif
+
+	if (clk == 0) {
+		clrbits_le32(&ccm->pll3_cfg, CCM_PLL3_CTRL_EN);
+		return;
+	}
+
+	/* PLL3 rate = 24000000 * n / m */
+	writel(CCM_PLL3_CTRL_EN | CCM_PLL3_CTRL_INTEGER_MODE |
+	       CCM_PLL3_CTRL_N(clk / (24000000 / m)) | CCM_PLL3_CTRL_M(m),
+	       &ccm->pll3_cfg);
+}
+
+#ifdef CONFIG_SUNXI_DE2
+void clock_set_pll3_factors(int m, int n)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+
+	/* PLL3 rate = 24000000 * n / m */
+	writel(CCM_PLL3_CTRL_EN | CCM_PLL3_CTRL_INTEGER_MODE |
+	       CCM_PLL3_CTRL_N(n) | CCM_PLL3_CTRL_M(m),
+	       &ccm->pll3_cfg);
+
+	while (!(readl(&ccm->pll3_cfg) & CCM_PLL3_CTRL_LOCK))
+		;
+}
+#endif
+
+void clock_set_pll5(unsigned int clk, bool sigma_delta_enable)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	const int max_n = 32;
+	int k = 1, m = 2;
+
+#ifdef CONFIG_MACH_SUNXI_H3_H5
+	clrsetbits_le32(&ccm->pll5_tuning_cfg, CCM_PLL5_TUN_LOCK_TIME_MASK |
+			CCM_PLL5_TUN_INIT_FREQ_MASK,
+			CCM_PLL5_TUN_LOCK_TIME(2) | CCM_PLL5_TUN_INIT_FREQ(16));
+#endif
+
+	if (sigma_delta_enable)
+		writel(CCM_PLL5_PATTERN, &ccm->pll5_pattern_cfg);
+
+	/* PLL5 rate = 24000000 * n * k / m */
+	if (clk > 24000000 * k * max_n / m) {
+		m = 1;
+		if (clk > 24000000 * k * max_n / m)
+			k = 2;
+	}
+	writel(CCM_PLL5_CTRL_EN |
+	       (sigma_delta_enable ? CCM_PLL5_CTRL_SIGMA_DELTA_EN : 0) |
+	       CCM_PLL5_CTRL_UPD |
+	       CCM_PLL5_CTRL_N(clk / (24000000 * k / m)) |
+	       CCM_PLL5_CTRL_K(k) | CCM_PLL5_CTRL_M(m), &ccm->pll5_cfg);
+
+	udelay(5500);
+}
+
+#ifdef CONFIG_MACH_SUN6I
+void clock_set_mipi_pll(unsigned int clk)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	unsigned int k, m, n, value, diff;
+	unsigned best_k = 0, best_m = 0, best_n = 0, best_diff = 0xffffffff;
+	unsigned int src = clock_get_pll3();
+
+	/* All calculations are in KHz to avoid overflows */
+	clk /= 1000;
+	src /= 1000;
+
+	/* Pick the closest lower clock */
+	for (k = 1; k <= 4; k++) {
+		for (m = 1; m <= 16; m++) {
+			for (n = 1; n <= 16; n++) {
+				value = src * n * k / m;
+				if (value > clk)
+					continue;
+
+				diff = clk - value;
+				if (diff < best_diff) {
+					best_diff = diff;
+					best_k = k;
+					best_m = m;
+					best_n = n;
+				}
+				if (diff == 0)
+					goto done;
+			}
+		}
+	}
+
+done:
+	writel(CCM_MIPI_PLL_CTRL_EN | CCM_MIPI_PLL_CTRL_LDO_EN |
+	       CCM_MIPI_PLL_CTRL_N(best_n) | CCM_MIPI_PLL_CTRL_K(best_k) |
+	       CCM_MIPI_PLL_CTRL_M(best_m), &ccm->mipi_pll_cfg);
+}
+#endif
+
+#ifdef CONFIG_SUNXI_DE2
+void clock_set_pll10(unsigned int clk)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	const int m = 2; /* 12 MHz steps */
+
+	if (clk == 0) {
+		clrbits_le32(&ccm->pll10_cfg, CCM_PLL10_CTRL_EN);
+		return;
+	}
+
+	/* PLL10 rate = 24000000 * n / m */
+	writel(CCM_PLL10_CTRL_EN | CCM_PLL10_CTRL_INTEGER_MODE |
+	       CCM_PLL10_CTRL_N(clk / (24000000 / m)) | CCM_PLL10_CTRL_M(m),
+	       &ccm->pll10_cfg);
+
+	while (!(readl(&ccm->pll10_cfg) & CCM_PLL10_CTRL_LOCK))
+		;
+}
+#endif
+
+#if defined(CONFIG_MACH_SUN8I_A33) || \
+    defined(CONFIG_MACH_SUN8I_R40) || \
+    defined(CONFIG_MACH_SUN50I)
+void clock_set_pll11(unsigned int clk, bool sigma_delta_enable)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+
+	if (sigma_delta_enable)
+		writel(CCM_PLL11_PATTERN, &ccm->pll11_pattern_cfg0);
+
+	writel(CCM_PLL11_CTRL_EN | CCM_PLL11_CTRL_UPD |
+	       (sigma_delta_enable ? CCM_PLL11_CTRL_SIGMA_DELTA_EN : 0) |
+	       CCM_PLL11_CTRL_N(clk / 24000000), &ccm->pll11_cfg);
+
+	while (readl(&ccm->pll11_cfg) & CCM_PLL11_CTRL_UPD)
+		;
+}
+#endif
+
+unsigned int clock_get_pll3(void)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	uint32_t rval = readl(&ccm->pll3_cfg);
+	int n = ((rval & CCM_PLL3_CTRL_N_MASK) >> CCM_PLL3_CTRL_N_SHIFT) + 1;
+	int m = ((rval & CCM_PLL3_CTRL_M_MASK) >> CCM_PLL3_CTRL_M_SHIFT) + 1;
+
+	/* Multiply by 1000 after dividing by m to avoid integer overflows */
+	return (24000 * n / m) * 1000;
+}
+
+unsigned int clock_get_pll6(void)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	uint32_t rval = readl(&ccm->pll6_cfg);
+	int n = ((rval & CCM_PLL6_CTRL_N_MASK) >> CCM_PLL6_CTRL_N_SHIFT) + 1;
+	int k = ((rval & CCM_PLL6_CTRL_K_MASK) >> CCM_PLL6_CTRL_K_SHIFT) + 1;
+#ifndef CONFIG_MACH_SUNIV
+	return 24000000 * n * k / 2;
+#else
+	return 24000000 * n * k;
+#endif
+}
+
+unsigned int clock_get_mipi_pll(void)
+{
+	struct sunxi_ccm_reg *const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	uint32_t rval = readl(&ccm->mipi_pll_cfg);
+	unsigned int n = ((rval & CCM_MIPI_PLL_CTRL_N_MASK) >> CCM_MIPI_PLL_CTRL_N_SHIFT) + 1;
+	unsigned int k = ((rval & CCM_MIPI_PLL_CTRL_K_MASK) >> CCM_MIPI_PLL_CTRL_K_SHIFT) + 1;
+	unsigned int m = ((rval & CCM_MIPI_PLL_CTRL_M_MASK) >> CCM_MIPI_PLL_CTRL_M_SHIFT) + 1;
+	unsigned int src = clock_get_pll3();
+
+	/* Multiply by 1000 after dividing by m to avoid integer overflows */
+	return ((src / 1000) * n * k / m) * 1000;
+}
+
+void clock_set_de_mod_clock(u32 *clk_cfg, unsigned int hz)
+{
+	int pll = clock_get_pll6() * 2;
+	int div = 1;
+
+	while ((pll / div) > hz)
+		div++;
+
+	writel(CCM_DE_CTRL_GATE | CCM_DE_CTRL_PLL6_2X | CCM_DE_CTRL_M(div),
+	       clk_cfg);
+}
diff --git a/arch/arm/mach-sunxi/dram_helpers.c b/arch/arm/mach-sunxi/dram_helpers.c
index 520b597f..2c873192 100644
--- a/arch/arm/mach-sunxi/dram_helpers.c
+++ b/arch/arm/mach-sunxi/dram_helpers.c
@@ -26,7 +26,10 @@ void mctl_await_completion(u32 *reg, u32 mask, u32 val)
 
 /*
  * Test if memory at offset offset matches memory at begin of DRAM
+ *
+ * Note: dsb() is not available on ARMv5 in Thumb mode
  */
+#ifndef CONFIG_MACH_SUNIV
 bool mctl_mem_matches(u32 offset)
 {
 	/* Try to write different values to RAM at two addresses */
@@ -37,3 +40,4 @@ bool mctl_mem_matches(u32 offset)
 	return readl(CONFIG_SYS_SDRAM_BASE) ==
 	       readl((ulong)CONFIG_SYS_SDRAM_BASE + offset);
 }
+#endif
diff --git a/arch/arm/mach-sunxi/dram_suniv.c b/arch/arm/mach-sunxi/dram_suniv.c
new file mode 100644
index 00000000..f5864b47
--- /dev/null
+++ b/arch/arm/mach-sunxi/dram_suniv.c
@@ -0,0 +1,484 @@
+/*
+ * suniv DRAM initialization
+ *
+ * Copyright (C) 2018 Icenowy Zheng <icenowy@aosc.io>
+ *
+ * Based on xboot's arch/arm32/mach-f1c100s/sys-dram.c, which is:
+ *
+ * Copyright(c) 2007-2018 Jianjun Jiang <8192542@qq.com>
+ *
+ * SPDX-License-Identifier:	GPL-2.0+
+ */
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/clock.h>
+#include <asm/arch/dram.h>
+#include <asm/arch/gpio.h>
+#include <linux/bitops.h>
+#include <linux/delay.h>
+
+enum dram_type
+{
+	DRAM_TYPE_SDR	= 0,
+	DRAM_TYPE_DDR	= 1,
+	/* Not supported yet. */
+	DRAM_TYPE_MDDR	= 2,
+};
+
+struct dram_para
+{
+	u32 size;		/* dram size (unit: MByte) */
+	u32 clk;		/* dram work clock (unit: MHz) */
+	u32 access_mode;	/* 0: interleave mode 1: sequence mode */
+	u32 cs_num;		/* dram chip count  1: one chip  2: two chip */
+	u32 ddr8_remap;		/* for 8bits data width DDR 0: normal  1: 8bits */
+	enum dram_type sdr_ddr;
+	u32 bwidth;		/* dram bus width */
+	u32 col_width;		/* column address width */
+	u32 row_width;		/* row address width */
+	u32 bank_size;		/* dram bank count */
+	u32 cas;		/* dram cas */
+};
+
+struct dram_para suniv_dram_para = {
+	.size = 32,
+	.clk = CONFIG_DRAM_CLK,
+	.access_mode = 1,
+	.cs_num = 1,
+	.ddr8_remap = 0,
+	.sdr_ddr = DRAM_TYPE_DDR,
+	.bwidth = 16,
+	.col_width = 10,
+	.row_width = 13,
+	.bank_size = 4,
+	.cas = 0x3,
+};
+
+static int dram_initial(void)
+{
+	unsigned int time = 0xffffff;
+
+	setbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR, 0x1);
+	while((readl(SUNXI_DRAMC_BASE + DRAM_SCTLR) & 0x1) && time--)
+	{
+		if(time == 0)
+			return 0;
+	}
+	return 1;
+}
+
+static int dram_delay_scan(void)
+{
+	unsigned int time = 0xffffff;
+
+	setbits_le32(SUNXI_DRAMC_BASE + DRAM_DDLYR, 0x1);
+	while((readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) & 0x1) && time--)
+	{
+		if(time == 0)
+			return 0;
+	}
+	return 1;
+}
+
+static void dram_set_autofresh_cycle(u32 clk)
+{
+	u32 val = 0;
+	u32 row = 0;
+	u32 temp = 0;
+
+	row = readl(SUNXI_DRAMC_BASE + DRAM_SCONR);
+	row &= 0x1e0;
+	row >>= 0x5;
+
+	if(row == 0xc)
+	{
+		if(clk >= 1000000)
+		{
+			temp = clk + (clk >> 3) + (clk >> 4) + (clk >> 5);
+			while(temp >= (10000000 >> 6))
+			{
+				temp -= (10000000 >> 6);
+				val++;
+			}
+		}
+		else
+		{
+			val = (clk * 499) >> 6;
+		}
+	}
+	else if(row == 0xb)
+	{
+		if(clk >= 1000000)
+		{
+			temp = clk + (clk >> 3) + (clk >> 4) + (clk >> 5);
+			while(temp >= (10000000 >> 7))
+			{
+				temp -= (10000000 >> 7);
+				val++;
+			}
+		}
+		else
+		{
+			val = (clk * 499) >> 5;
+		}
+	}
+	writel(val, SUNXI_DRAMC_BASE + DRAM_SREFR);
+}
+
+static int dram_para_setup(struct dram_para * para)
+{
+	u32 val = 0;
+
+	val = (para->ddr8_remap) | (0x1 << 1) |
+	      ((para->bank_size >> 2) << 3) |
+	      ((para->cs_num >> 1) << 4) |
+	      ((para->row_width - 1) << 5) |
+	      ((para->col_width - 1) << 9) |
+	      ((para->sdr_ddr ? (para->bwidth >> 4) : (para->bwidth >> 5)) << 13) |
+	      (para->access_mode << 15) |
+	      (para->sdr_ddr << 16);
+
+	writel(val, SUNXI_DRAMC_BASE + DRAM_SCONR);
+	setbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR, 0x1 << 19);
+	return dram_initial();
+}
+
+static u32 dram_check_delay(u32 bwidth)
+{
+	u32 dsize;
+	int i,j;
+	u32 num = 0;
+	u32 dflag = 0;
+
+	dsize = ((bwidth == 16) ? 4 : 2);
+	for(i = 0; i < dsize; i++)
+	{
+		if(i == 0)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR0);
+		else if(i == 1)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR1);
+		else if(i == 2)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR2);
+		else if(i == 3)
+			dflag = readl(SUNXI_DRAMC_BASE + DRAM_DRPTR3);
+
+		for(j = 0; j < 32; j++)
+		{
+			if(dflag & 0x1)
+				num++;
+			dflag >>= 1;
+		}
+	}
+	return num;
+}
+
+static int sdr_readpipe_scan(void)
+{
+	u32 k = 0;
+
+	for(k = 0; k < 32; k++)
+	{
+		writel(k, CONFIG_SYS_SDRAM_BASE + 4 * k);
+	}
+	for(k = 0; k < 32; k++)
+	{
+		if(readl(CONFIG_SYS_SDRAM_BASE + 4 * k) != k)
+			return 0;
+	}
+	return 1;
+}
+
+static u32 sdr_readpipe_select(void)
+{
+	u32 value = 0;
+	u32 i = 0;
+	for(i = 0; i < 8; i++)
+	{
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, i << 6);
+		if(sdr_readpipe_scan())
+		{
+			value = i;
+			return value;
+		}
+	}
+	return value;
+}
+
+static u32 dram_check_type(struct dram_para * para)
+{
+	u32 times = 0;
+	int i;
+
+	for(i = 0; i < 8; i++)
+	{
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, i << 6);
+		dram_delay_scan();
+		if(readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) & 0x30)
+			times++;
+	}
+
+	if(times == 8)
+	{
+		para->sdr_ddr = DRAM_TYPE_SDR;
+		return 0;
+	}
+	else
+	{
+		para->sdr_ddr = DRAM_TYPE_DDR;
+		return 1;
+	}
+}
+
+static u32 dram_scan_readpipe(struct dram_para * para)
+{
+	u32 rp_best = 0, rp_val = 0;
+	u32 readpipe[8];
+	int i;
+
+	if(para->sdr_ddr == DRAM_TYPE_DDR)
+	{
+		for(i = 0; i < 8; i++)
+		{
+			clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+					0x7 << 6, i << 6);
+			dram_delay_scan();
+			readpipe[i] = 0;
+			if((((readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) >> 4) & 0x3) == 0x0) &&
+				(((readl(SUNXI_DRAMC_BASE + DRAM_DDLYR) >> 4) & 0x1) == 0x0))
+			{
+				readpipe[i] = dram_check_delay(para->bwidth);
+			}
+			if(rp_val < readpipe[i])
+			{
+				rp_val = readpipe[i];
+				rp_best = i;
+			}
+		}
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, rp_best << 6);
+		dram_delay_scan();
+	}
+	else
+	{
+		clrbits_le32(SUNXI_DRAMC_BASE + DRAM_SCONR,
+			     (0x1 << 16) | (0x3 << 13));
+		rp_best = sdr_readpipe_select();
+		clrsetbits_le32(SUNXI_DRAMC_BASE + DRAM_SCTLR,
+				0x7 << 6, rp_best << 6);
+	}
+	return 0;
+}
+
+static u32 dram_get_dram_size(struct dram_para * para)
+{
+	u32 colflag = 10, rowflag = 13;
+	u32 val1 = 0;
+	u32 count = 0;
+	u32 addr1, addr2;
+	int i;
+
+	para->col_width = colflag;
+	para->row_width = rowflag;
+	dram_para_setup(para);
+	dram_scan_readpipe(para);
+	for(i = 0; i < 32; i++)
+	{
+		*((u8 *)(CONFIG_SYS_SDRAM_BASE + 0x200 + i)) = 0x11;
+		*((u8 *)(CONFIG_SYS_SDRAM_BASE + 0x600 + i)) = 0x22;
+	}
+	for(i = 0; i < 32; i++)
+	{
+		val1 = *((u8 *)(CONFIG_SYS_SDRAM_BASE + 0x200 + i));
+		if(val1 == 0x22)
+			count++;
+	}
+	if(count == 32)
+	{
+		colflag = 9;
+	}
+	else
+	{
+		colflag = 10;
+	}
+	count = 0;
+	para->col_width = colflag;
+	para->row_width = rowflag;
+	dram_para_setup(para);
+	if(colflag == 10)
+	{
+		addr1 = CONFIG_SYS_SDRAM_BASE + 0x400000;
+		addr2 = CONFIG_SYS_SDRAM_BASE + 0xc00000;
+	}
+	else
+	{
+		addr1 = CONFIG_SYS_SDRAM_BASE + 0x200000;
+		addr2 = CONFIG_SYS_SDRAM_BASE + 0x600000;
+	}
+	for(i = 0; i < 32; i++)
+	{
+		*((u8 *)(addr1 + i)) = 0x33;
+		*((u8 *)(addr2 + i)) = 0x44;
+	}
+	for(i = 0; i < 32; i++)
+	{
+		val1 = *((u8 *)(addr1 + i));
+		if(val1 == 0x44)
+		{
+			count++;
+		}
+	}
+	if(count == 32)
+	{
+		rowflag = 12;
+	}
+	else
+	{
+		rowflag = 13;
+	}
+	para->col_width = colflag;
+	para->row_width = rowflag;
+	if(para->row_width != 13)
+	{
+		para->size = 16;
+	}
+	else if(para->col_width == 10)
+	{
+		para->size = 64;
+	}
+	else
+	{
+		para->size = 32;
+	}
+	dram_set_autofresh_cycle(para->clk);
+	para->access_mode = 0;
+	dram_para_setup(para);
+
+	return 0;
+}
+
+static void simple_dram_check(void)
+{
+	volatile u32 *dram = (u32*) CONFIG_SYS_SDRAM_BASE;
+	int i;
+
+	for(i = 0; i < 0x40; i++)
+	{
+		dram[i] = i;
+	}
+
+	for(i = 0; i < 0x40; i++)
+	{
+		if (dram[i] != i) {
+			printf("DRAM initialization failed: dram[0x%x] != 0x%x.", i, dram[i]);
+			while(1) {}
+		}
+	}
+
+	for(i = 0; i < 0x10000; i += 0x40)
+	{
+		dram[i] = i;
+	}
+
+	for(i = 0; i < 0x10000; i += 0x40)
+	{
+		if (dram[i] != i) {
+			printf("DRAM initialization failed: dram[0x%x] != 0x%x.", i, dram[i]);
+			while(1) {}
+		}
+	}
+}
+
+static void do_dram_init(struct dram_para * para)
+{
+	struct sunxi_ccm_reg * const ccm =
+		(struct sunxi_ccm_reg *)SUNXI_CCM_BASE;
+	u32 val;
+	u8 m; /* PLL_DDR clock factor */
+
+	sunxi_gpio_set_cfgpin(SUNXI_GPB(3), 0x7);
+	udelay(5000);
+	/* TODO: dig out what's them... some analog register? */
+	if(((para->cas) >> 3) & 0x1)
+	{
+		setbits_le32(SUNXI_PIO_BASE + 0x2c4, (0x1 << 23) | (0x20 << 17));
+	}
+
+	if((para->clk >= 144) && (para->clk <= 180))
+	{
+		writel(0xaaa, SUNXI_PIO_BASE + 0x2c0);
+	}
+	if(para->clk >= 180)
+	{
+		writel(0xfff, SUNXI_PIO_BASE + 0x2c0);
+	}
+
+	if(para->cas & BIT(4))
+	{
+		writel(0xd1303333, &ccm->pll5_pattern_cfg);
+	}
+	else if(para->cas & BIT(5))
+	{
+		writel(0xcce06666, &ccm->pll5_pattern_cfg);
+	}
+	else if(para->cas & BIT(6))
+	{
+		writel(0xc8909999, &ccm->pll5_pattern_cfg);
+	}
+	else if(para->cas & BIT(7))
+	{
+		writel(0xc440cccc, &ccm->pll5_pattern_cfg);
+	}
+
+	if((para->clk) <= 96)
+		m = 2;
+	else
+		m = 1;
+
+	val = CCM_PLL5_CTRL_EN | CCM_PLL5_CTRL_UPD |
+	      CCM_PLL5_CTRL_N((para->clk * 2) / (24 / m)) |
+	      CCM_PLL5_CTRL_K(1) | CCM_PLL5_CTRL_M(m);
+	if(para->cas & GENMASK(7, 4))
+	{
+		val |= CCM_PLL5_CTRL_SIGMA_DELTA_EN;
+	}
+	writel(val, &ccm->pll5_cfg);
+	setbits_le32(&ccm->pll5_cfg, CCM_PLL5_CTRL_UPD);
+	mctl_await_completion(&ccm->pll5_cfg, BIT(28), BIT(28));
+	udelay(5000);
+
+	setbits_le32(&ccm->ahb_gate0, (1 << AHB_GATE_OFFSET_MCTL));
+	clrbits_le32(&ccm->ahb_reset0_cfg, (1 << AHB_RESET_OFFSET_MCTL));
+	udelay(50);
+	setbits_le32(&ccm->ahb_reset0_cfg, (1 << AHB_RESET_OFFSET_MCTL));
+
+	clrsetbits_le32(SUNXI_PIO_BASE + 0x2c4, (1 << 16),
+			((para->sdr_ddr == DRAM_TYPE_DDR) << 16));
+
+	val = (0x2 << 0) | (0x8 << 3) | (0x3 << 7) |
+	      (0x3 << 10) | (0x3 << 13) | (0xd << 15) |
+	      (0xf9 << 19) | (0xb << 28);
+	writel(val, SUNXI_DRAMC_BASE + DRAM_STMG0R);
+	val = (0x8 << 0) | (0x7 << 16) | (0x2 << 20) |
+	      (0x2 << 22) | (0x0 << 25);
+	writel(val, SUNXI_DRAMC_BASE + DRAM_STMG1R);
+	dram_para_setup(para);
+	dram_check_type(para);
+
+	clrsetbits_le32(SUNXI_PIO_BASE + 0x2c4, (1 << 16),
+			((para->sdr_ddr == DRAM_TYPE_DDR) << 16));
+
+	dram_set_autofresh_cycle(para->clk);
+	dram_scan_readpipe(para);
+	dram_get_dram_size(para);
+	simple_dram_check();
+}
+
+unsigned long sunxi_dram_init(void)
+{
+	do_dram_init(&suniv_dram_para);
+
+	return suniv_dram_para.size * 1024 * 1024;
+}
diff --git a/arch/arm/mach-sunxi/spl_spi_sunxi.c b/arch/arm/mach-sunxi/spl_spi_sunxi.c
index 15e86cba..25fd17a3 100644
--- a/arch/arm/mach-sunxi/spl_spi_sunxi.c
+++ b/arch/arm/mach-sunxi/spl_spi_sunxi.c
@@ -12,6 +12,7 @@
 #include <linux/bitops.h>
 #include <linux/delay.h>
 #include <linux/libfdt.h>
+#include <asm/arch/spl.h>
 
 #ifdef CONFIG_SPL_OS_BOOT
 #error CONFIG_SPL_OS_BOOT is not supported yet
@@ -89,6 +90,7 @@
 
 #define SPI0_CLK_DIV_BY_2           0x1000
 #define SPI0_CLK_DIV_BY_4           0x1001
+#define SPI0_CLK_DIV_BY_32          0x100f
 
 /*****************************************************************************/
 
@@ -120,7 +122,8 @@ static void spi0_pinmux_setup(unsigned int pin_function)
 static bool is_sun6i_gen_spi(void)
 {
 	return IS_ENABLED(CONFIG_SUNXI_GEN_SUN6I) ||
-	       IS_ENABLED(CONFIG_MACH_SUN50I_H6);
+	       IS_ENABLED(CONFIG_MACH_SUN50I_H6) ||
+		   IS_ENABLED(CONFIG_MACH_SUNIV);
 }
 
 static uintptr_t spi0_base_address(void)
@@ -131,6 +134,9 @@ static uintptr_t spi0_base_address(void)
 	if (IS_ENABLED(CONFIG_MACH_SUN50I_H6))
 		return 0x05010000;
 
+	if (IS_ENABLED(CONFIG_MACH_SUNIV))
+		return 0x01C05000;
+
 	if (!is_sun6i_gen_spi())
 		return 0x01C05000;
 
@@ -155,11 +161,17 @@ static void spi0_enable_clock(void)
 	if (!IS_ENABLED(CONFIG_MACH_SUN50I_H6))
 		setbits_le32(CCM_AHB_GATING0, (1 << AHB_GATE_OFFSET_SPI0));
 
+#ifndef CONFIG_MACH_SUNIV
 	/* Divide by 4 */
 	writel(SPI0_CLK_DIV_BY_4, base + (is_sun6i_gen_spi() ?
 				  SUN6I_SPI0_CCTL : SUN4I_SPI0_CCTL));
 	/* 24MHz from OSC24M */
 	writel((1 << 31), CCM_SPI0_CLK);
+#else
+	/* Divide by 32, clock source is AHB clock 200MHz */
+	writel(SPI0_CLK_DIV_BY_32, base + (is_sun6i_gen_spi() ?
+				  SUN6I_SPI0_CCTL : SUN4I_SPI0_CCTL));
+#endif
 
 	if (is_sun6i_gen_spi()) {
 		/* Enable SPI in the master mode and do a soft reset */
@@ -189,8 +201,10 @@ static void spi0_disable_clock(void)
 		clrbits_le32(base + SUN4I_SPI0_CTL, SUN4I_CTL_MASTER |
 					     SUN4I_CTL_ENABLE);
 
+#ifndef CONFIG_MACH_SUNIV
 	/* Disable the SPI0 clock */
 	writel(0, CCM_SPI0_CLK);
+#endif
 
 	/* Close the SPI0 gate */
 	if (!IS_ENABLED(CONFIG_MACH_SUN50I_H6))
@@ -212,6 +226,9 @@ static void spi0_init(void)
 	    IS_ENABLED(CONFIG_MACH_SUN50I_H6))
 		pin_function = SUN50I_GPC_SPI0;
 
+	if (IS_ENABLED(CONFIG_MACH_SUNIV))
+		pin_function = SUNIV_GPC_SPI0;
+
 	spi0_pinmux_setup(pin_function);
 	spi0_enable_clock();
 }
@@ -228,11 +245,9 @@ static void spi0_deinit(void)
 	spi0_pinmux_setup(pin_function);
 }
 
-/*****************************************************************************/
-
-#define SPI_READ_MAX_SIZE 60 /* FIFO size, minus 4 bytes of the header */
-
-static void sunxi_spi0_read_data(u8 *buf, u32 addr, u32 bufsize,
+static void sunxi_spi0_transmit(
+				 u8 *send, u32 ssize,
+				 u8*recv, u32 rsize,
 				 ulong spi_ctl_reg,
 				 ulong spi_ctl_xch_bitmask,
 				 ulong spi_fifo_reg,
@@ -242,67 +257,172 @@ static void sunxi_spi0_read_data(u8 *buf, u32 addr, u32 bufsize,
 				 ulong spi_tc_reg,
 				 ulong spi_bcc_reg)
 {
-	writel(4 + bufsize, spi_bc_reg); /* Burst counter (total bytes) */
-	writel(4, spi_tc_reg);           /* Transfer counter (bytes to send) */
+	writel(ssize + rsize, spi_bc_reg); /* Burst counter (total bytes) */
+	writel(ssize, spi_tc_reg);           /* Transfer counter (bytes to send) */
 	if (spi_bcc_reg)
-		writel(4, spi_bcc_reg);  /* SUN6I also needs this */
+		writel(ssize, spi_bcc_reg);  /* SUN6I also needs this */
 
-	/* Send the Read Data Bytes (03h) command header */
-	writeb(0x03, spi_tx_reg);
-	writeb((u8)(addr >> 16), spi_tx_reg);
-	writeb((u8)(addr >> 8), spi_tx_reg);
-	writeb((u8)(addr), spi_tx_reg);
+	/* Send buffer */
+	for(u32 i = 0; i < ssize; i++)
+		writeb(send[i], spi_tx_reg);
 
 	/* Start the data transfer */
 	setbits_le32(spi_ctl_reg, spi_ctl_xch_bitmask);
 
 	/* Wait until everything is received in the RX FIFO */
-	while ((readl(spi_fifo_reg) & 0x7F) < 4 + bufsize)
+	while ((readl(spi_fifo_reg) & 0x7F) < ssize + rsize)
 		;
 
-	/* Skip 4 bytes */
-	readl(spi_rx_reg);
+	/* Skip send bytes */
+	for(u32 i = 0; i < ssize; i++)
+		readb(spi_rx_reg);
 
 	/* Read the data */
-	while (bufsize-- > 0)
-		*buf++ = readb(spi_rx_reg);
+	while (rsize-- > 0)
+		*recv++ = readb(spi_rx_reg);
 
 	/* tSHSL time is up to 100 ns in various SPI flash datasheets */
 	udelay(1);
 }
 
+static void spi0_transmit(
+				 void *send, u32 ssize,
+				 void *recv, u32 rsize)
+{
+	u8 *sbuf = send;
+	u8 *rbuf = recv;
+	uintptr_t base = spi0_base_address();
+	if (is_sun6i_gen_spi()) {
+		sunxi_spi0_transmit(
+					 sbuf, ssize,
+					 rbuf, rsize,
+					 base + SUN6I_SPI0_TCR,
+					 SUN6I_TCR_XCH,
+					 base + SUN6I_SPI0_FIFO_STA,
+					 base + SUN6I_SPI0_TXD,
+					 base + SUN6I_SPI0_RXD,
+					 base + SUN6I_SPI0_MBC,
+					 base + SUN6I_SPI0_MTC,
+					 base + SUN6I_SPI0_BCC);
+	} else {
+		sunxi_spi0_transmit(
+					 sbuf, ssize,
+					 rbuf, rsize,
+					 base + SUN4I_SPI0_CTL,
+					 SUN4I_CTL_XCH,
+					 base + SUN4I_SPI0_FIFO_STA,
+					 base + SUN4I_SPI0_TX,
+					 base + SUN4I_SPI0_RX,
+					 base + SUN4I_SPI0_BC,
+					 base + SUN4I_SPI0_TC,
+					 0);
+	}
+}
+
+enum flashtype
+{
+	FLASHTYPE_UNINIT,
+	FLASHTYPE_NOR,
+	FLASHTYPE_NAND,
+};
+
+static enum flashtype spi0_get_flash_type(void)
+{
+	static enum flashtype type;
+	static u8 chipid[2];
+	if(type == FLASHTYPE_UNINIT)
+	{
+		type = FLASHTYPE_NOR;
+		spi0_transmit("\x9f\x00", 2, chipid, 2); // Read Chip ID
+		if (!memcmp(chipid, "\xc8\xf1", 2)) {
+			printf("SPI-NAND: GigaDevice GD5F1GQ4UAYIG\n");
+			type = FLASHTYPE_NAND;
+		}
+		else if (!memcmp(chipid, "\xc8\x51", 2)) {
+			printf("SPI-NAND: GigaDevice GD5F1GQ5UEYIG\n");
+			type = FLASHTYPE_NAND;
+		}
+		else if (!memcmp(chipid, "\xef\xaa", 2)) {
+			printf("SPI-NAND: Winbond W25N01G\n");
+			type = FLASHTYPE_NAND;
+		}
+		else if (!memcmp(chipid, "\xef\xab", 2)) {
+			printf("SPI-NAND: Winbond W25M02GV\n");
+			type = FLASHTYPE_NAND;
+		}
+	}
+	return type;
+}
+
+static u32 nandpage = -1;
+
+static u32 spi0_read_small_data(void *buf, u32 addr, u32 len)
+{
+	switch(spi0_get_flash_type())
+	{
+	case FLASHTYPE_NAND:
+	{
+		u32 page, wrap;
+		page = addr >> 11;
+		if (nandpage != page) {
+			u8 readcache[] = {0x13, (u8)(page >> 16), (u8)(page >> 8), (u8)(page)};
+			spi0_transmit(readcache, 4, NULL, 0);
+			udelay(300);
+			nandpage = page;
+		}
+		addr &= 0x7FF;
+		if (len + addr > 0x800) 
+			len = 0x800 - addr;
+		if (len > 0 && len <= 16) {
+            wrap = 12;
+        } else if(len > 16 && len <= 64) {
+            wrap = 8;
+        } else if(len > 65 && len <= 2048) {
+            wrap = 4;
+        } else {
+            wrap = 0;
+        }
+		switch(wrap)
+		{
+		case 12:
+			if((addr & 0xF) + len > 16) wrap = 8;
+			break;
+		case 8:
+			if((addr & 0x3F) + len > 65) wrap = 4;
+			break;
+		default:
+			wrap = 0;
+			break;
+		}
+		u8 read[] = {0x03, (u8)((addr >> 8) & 0xF) | (wrap << 4), addr & 0xFF, 0};
+		spi0_transmit(read, 4, buf, len);
+	}
+	break;
+	default:
+	{
+		u8 read[] = {0x03, (u8)(addr >> 16), (u8)(addr >> 8), (u8)(addr)};
+		spi0_transmit(read, 4, buf, len);
+	}
+	break;
+	}
+	return len;
+}
+
+/*****************************************************************************/
+
+#define SPI_READ_MAX_SIZE 60 /* FIFO size, minus 4 bytes of the header */
+
 static void spi0_read_data(void *buf, u32 addr, u32 len)
 {
 	u8 *buf8 = buf;
 	u32 chunk_len;
-	uintptr_t base = spi0_base_address();
 
 	while (len > 0) {
 		chunk_len = len;
 		if (chunk_len > SPI_READ_MAX_SIZE)
 			chunk_len = SPI_READ_MAX_SIZE;
-
-		if (is_sun6i_gen_spi()) {
-			sunxi_spi0_read_data(buf8, addr, chunk_len,
-					     base + SUN6I_SPI0_TCR,
-					     SUN6I_TCR_XCH,
-					     base + SUN6I_SPI0_FIFO_STA,
-					     base + SUN6I_SPI0_TXD,
-					     base + SUN6I_SPI0_RXD,
-					     base + SUN6I_SPI0_MBC,
-					     base + SUN6I_SPI0_MTC,
-					     base + SUN6I_SPI0_BCC);
-		} else {
-			sunxi_spi0_read_data(buf8, addr, chunk_len,
-					     base + SUN4I_SPI0_CTL,
-					     SUN4I_CTL_XCH,
-					     base + SUN4I_SPI0_FIFO_STA,
-					     base + SUN4I_SPI0_TX,
-					     base + SUN4I_SPI0_RX,
-					     base + SUN4I_SPI0_BC,
-					     base + SUN4I_SPI0_TC,
-					     0);
-		}
+		
+		chunk_len = spi0_read_small_data(buf8, addr, chunk_len);
 
 		len  -= chunk_len;
 		buf8 += chunk_len;
@@ -324,14 +444,28 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 			      struct spl_boot_device *bootdev)
 {
 	int ret = 0;
+	u32 uboot_addr;
 	struct image_header *header;
 	header = (struct image_header *)(CONFIG_SYS_TEXT_BASE);
+	uboot_addr = CONFIG_SYS_SPI_U_BOOT_OFFS;
 
 	spi0_init();
+	
+#ifdef CONFIG_MACH_SUNIV
+	unsigned char *buffer = (unsigned char *)(CONFIG_SYS_TEXT_BASE);
+	spi0_read_data(buffer, 0, 16);
+	if (!is_boot0_magic(buffer + 4)) {
+		return -1;
+	}
+	if (spi0_get_flash_type() == FLASHTYPE_NAND) {
+		printf("SPI-NAND: U-Boot address: %u\n", CONFIG_SYS_SPI_NAND_U_BOOT_OFFS);
+		uboot_addr = CONFIG_SYS_SPI_NAND_U_BOOT_OFFS;
+	}
+#endif
+	
+	spi0_read_data((void *)header, uboot_addr, 0x40);
 
-	spi0_read_data((void *)header, CONFIG_SYS_SPI_U_BOOT_OFFS, 0x40);
-
-        if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
+    if (IS_ENABLED(CONFIG_SPL_LOAD_FIT) &&
 		image_get_magic(header) == FDT_MAGIC) {
 		struct spl_load_info load;
 
@@ -342,14 +476,14 @@ static int spl_spi_load_image(struct spl_image_info *spl_image,
 		load.bl_len = 1;
 		load.read = spi_load_read;
 		ret = spl_load_simple_fit(spl_image, &load,
-					  CONFIG_SYS_SPI_U_BOOT_OFFS, header);
+					  uboot_addr, header);
 	} else {
 		ret = spl_parse_image_header(spl_image, header);
 		if (ret)
 			return ret;
 
 		spi0_read_data((void *)spl_image->load_addr,
-			       CONFIG_SYS_SPI_U_BOOT_OFFS, spl_image->size);
+			       uboot_addr, spl_image->size);
 	}
 
 	spi0_deinit();
-- 
2.17.1

